# Plugin Development Overview

NocoBase uses a micro-kernel architecture, where the core is only responsible for plugin lifecycle scheduling, dependency management, and encapsulating basic capabilities. All business features (including interfaces, permissions, automated processing, etc.) are provided or extended in the form of plugins. Therefore, understanding how plugins are organized, their lifecycle, and management methods is the first step to customizing NocoBase.

## Core Concepts

- **Plug and play**: Plugins can be installed, enabled, or disabled on demand, allowing different business models to be assembled without modifying the core.
- **Front-end and back-end integration**: A plugin usually includes both server-side and client-side implementations to maintain consistency between data logic and interface behavior.
- **Modular evolution**: Through plugin dependencies, large features can be broken down, allowing for gradual iteration and reuse of existing capabilities.

## Basic Plugin Structure

Each plugin is an independent npm package and adheres to a minimal directory structure:

```bash
plugin-hello/
├─ package.json          # Declares name, dependencies, and NocoBase plugin metadata
├─ client.js             # Build artifact, loaded by the front-end runtime
├─ server.js             # Build artifact, loaded by the server-side runtime
├─ src/
│  ├─ client             # Client-side source code, can register blocks, actions, fields, etc.
│  │  └─ ...
│  └─ server             # Server-side source code, can register resources, events, command lines, etc.
│     └─ ...
```

- The `name` and `version` in `package.json` must conform to npm specifications, and the plugin metadata (such as enabled status, dependencies, etc.) should be described in the `nocobase` field.
- `client.js` and `server.js` are typically generated by the `yarn build` process. During development, you edit the `src` directory directly; for release, you need to build them into JS files to be loaded at runtime.

## Directory Conventions and Loading Order

NocoBase scans the following directories for plugins by default:

```bash
my-nocobase-app/
├── packages/
│   └── plugins/          # Plugins developed from source code (high priority)
└── storage/
    └── plugins/          # Compiled plugins, including those uploaded from the interface
```

- `packages/plugins`: Suitable for maintenance alongside application source code, supports TypeScript and source code debugging.
- `storage/plugins`: Stores packaged plugin archives or build artifacts, mostly used in production environments or for plugins uploaded from the UI.
- If a plugin with the same name exists in both directories, the version in `packages/plugins` will be loaded with priority, which is convenient for local debugging to override the production version.

## Plugin Lifecycle and States

A plugin typically goes through the following states:

1.  **Create**: Initialize the plugin skeleton via CLI or import source code from an external source.
2.  **Add**: Download (or link dependencies in a monorepo) the plugin package locally, without writing registration information to the database yet.
3.  **Enable**: The first time it is enabled, it completes "registration + initialization"—writing database metadata and loading front-end and back-end entry points; subsequent enabling only executes the loading logic.
4.  **Disable**: Unload the front-end and back-end entry points, releasing resources but retaining the registered information.
5.  **Remove**: Completely remove the plugin and its persistent configuration and registration records.

Notes:
- `add` is only responsible for fetching (downloading) the plugin package; the actual installation is triggered by the first `enable`.
- If a package is only added but not enabled, the plugin will not appear in the runtime features.

These operations can be performed in the admin interface or executed in batches via the CLI:

```bash
# 1. Create a plugin skeleton
yarn pm create @my-project/plugin-hello
# 2. Add (download/link) the plugin package
yarn pm add @my-project/plugin-hello
# 3. Enable (also completes installation on first enable)
yarn pm enable @my-project/plugin-hello
# 4. Disable
yarn pm disable @my-project/plugin-hello
# 5. Remove
yarn pm remove @my-project/plugin-hello
```

If there are dependencies between plugins, the system will check version constraints on the first enable and will prompt about potentially affected plugins when disabling or removing.

## Plugin Manager Interface

Access the Plugin Manager in your browser (default address: http://localhost:13000/admin/settings/plugin-manager) to:

- View the list of plugins and their statuses (installed, enabled, not enabled, etc.).
- Upload plugin packages for easy migration between different environments.
- View plugin descriptions, versions, and dependency information.


![Plugin Manager](https://static-docs.nocobase.com/f914d978dbfd8c45a650bd88ef867832.png)


The interface operations and CLI commands share the same underlying logic. The choice of which method to use depends on the scenario: command line is more suitable for batch operations, while the interface is better for piecemeal management or for non-technical users.