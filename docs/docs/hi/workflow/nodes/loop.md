---
pkg: '@nocobase/plugin-workflow-loop'
---
:::tip
यह दस्तावेज़ AI द्वारा अनुवादित किया गया है। किसी भी अशुद्धि के लिए, कृपया [अंग्रेजी संस्करण](/en) देखें
:::


# लूप

## परिचय

लूप प्रोग्रामिंग भाषाओं में `for`/`while`/`forEach` जैसी सिंटैक्स संरचनाओं के समान है। जब आपको कुछ ऑपरेशंस को एक निश्चित संख्या में बार-बार दोहराने की आवश्यकता हो या किसी डेटा **संग्रह** (ऐरे) के लिए उन्हें दोहराना हो, तो आप लूप नोड का उपयोग कर सकते हैं।

## इंस्टॉलेशन

यह एक बिल्ट-इन **प्लगइन** है और इसे इंस्टॉल करने की आवश्यकता नहीं है।

## नोड बनाना

**वर्कफ़्लो** कॉन्फ़िगरेशन इंटरफ़ेस में, फ़्लो में प्लस ("+") बटन पर क्लिक करके "लूप" नोड जोड़ें:

![लूप नोड बनाना](https://static-docs.nocobase.com/b3c8061a66bfff037f4b9509ab0aad75.png)

लूप नोड बनाने के बाद, लूप के अंदर एक ब्रांच बन जाएगी। आप इस ब्रांच के अंदर कितने भी नोड जोड़ सकते हैं। ये नोड **वर्कफ़्लो** संदर्भ के वेरिएबल्स का उपयोग करने के अलावा, लूप संदर्भ के लोकल वेरिएबल्स का भी उपयोग कर सकते हैं, जैसे लूप **संग्रह** में प्रत्येक लूप में प्राप्त **डेटा** ऑब्जेक्ट, या लूप काउंट का इंडेक्स (इंडेक्स `0` से शुरू होता है)। लोकल वेरिएबल्स का स्कोप केवल लूप के अंदर तक सीमित होता है। यदि कई स्तरों पर लूप नेस्टेड हैं, तो आप प्रत्येक स्तर पर विशिष्ट लूप के लोकल वेरिएबल्स का उपयोग कर सकते हैं।

## नोड कॉन्फ़िगरेशन

![नोड कॉन्फ़िगरेशन](https://static-docs.nocobase.com/20241016135326.png)

### लूप ऑब्जेक्ट

लूप, लूप ऑब्जेक्ट के विभिन्न **डेटा** प्रकारों के आधार पर अलग-अलग तरीके से काम करता है:

1.  **ऐरे**: यह सबसे सामान्य स्थिति है। आमतौर पर आप **वर्कफ़्लो** संदर्भ से एक वेरिएबल चुन सकते हैं, जैसे किसी क्वेरी नोड के कई **डेटा** परिणाम, या प्रीलोड किया गया वन-टू-मेनी संबंध **डेटा**। यदि एक ऐरे चुना जाता है, तो लूप नोड ऐरे के प्रत्येक एलिमेंट पर इटरेट करेगा, और प्रत्येक इटिरेशन में वर्तमान एलिमेंट को लूप संदर्भ के लोकल वेरिएबल को असाइन करेगा।

2.  **संख्या**: जब चुना गया वेरिएबल एक संख्या हो, तो इसे इटिरेशन की संख्या के रूप में उपयोग किया जाएगा। संख्या का मान केवल धनात्मक पूर्णांकों का समर्थन करता है; ऋणात्मक संख्याएँ लूप में प्रवेश नहीं करेंगी, और दशमलव संख्या का दशमलव भाग अनदेखा कर दिया जाएगा। लोकल वेरिएबल में लूप काउंट का इंडेक्स ही लूप ऑब्जेक्ट का मान होता है। यह मान **0** से शुरू होता है। उदाहरण के लिए, यदि लूप ऑब्जेक्ट संख्या 5 है, तो प्रत्येक लूप में ऑब्जेक्ट और इंडेक्स क्रमशः होंगे: 0, 1, 2, 3, 4।

3.  **स्ट्रिंग**: जब चुना गया वेरिएबल एक स्ट्रिंग हो, तो इसकी लंबाई को इटिरेशन की संख्या के रूप में उपयोग किया जाएगा, और स्ट्रिंग के प्रत्येक कैरेक्टर को इंडेक्स के अनुसार प्रोसेस किया जाएगा।

4.  **अन्य**: अन्य प्रकार के मान (ऑब्जेक्ट प्रकार सहित) केवल एक बार प्रोसेस किए जाने वाले लूप ऑब्जेक्ट के रूप में माने जाते हैं, और केवल एक बार लूप करेंगे। आमतौर पर, ऐसी स्थिति में लूप का उपयोग करने की आवश्यकता नहीं होती है।

वेरिएबल चुनने के अलावा, आप संख्या और स्ट्रिंग प्रकारों के लिए सीधे स्थिरांक (constants) भी इनपुट कर सकते हैं। उदाहरण के लिए, `5` (संख्या प्रकार) इनपुट करने पर, लूप नोड 5 बार इटरेट करेगा। `abc` (स्ट्रिंग प्रकार) इनपुट करने पर, लूप नोड 3 बार इटरेट करेगा, और क्रमशः `a`, `b`, `c` इन तीन कैरेक्टर्स को प्रोसेस करेगा। वेरिएबल चयन टूल में, उस प्रकार का चयन करें जिसका आप स्थिरांक के लिए उपयोग करना चाहते हैं।

### लूप कंडीशन

`v1.4.0-beta` संस्करण से, लूप शर्तों से संबंधित नए विकल्प जोड़े गए हैं। आप नोड कॉन्फ़िगरेशन में लूप शर्तों को सक्षम कर सकते हैं।

**कंडीशन**

कंडीशन नोड में कंडीशन कॉन्फ़िगरेशन के समान, आप कॉन्फ़िगरेशन को संयोजित कर सकते हैं, और वर्तमान लूप में वेरिएबल्स का उपयोग कर सकते हैं, जैसे लूप ऑब्जेक्ट, लूप इंडेक्स आदि।

**जाँच का समय**

प्रोग्रामिंग भाषाओं के `while` और `do/while` कंस्ट्रक्ट्स के समान, आप प्रत्येक लूप शुरू होने से पहले या प्रत्येक लूप समाप्त होने के बाद कॉन्फ़िगर की गई शर्त का मूल्यांकन करना चुन सकते हैं। पोस्ट-कंडीशन मूल्यांकन लूप बॉडी के भीतर अन्य नोड्स को एक बार निष्पादित करने की अनुमति देता है, इससे पहले कि शर्त की जाँच की जाए।

**जब कंडीशन पूरी न हो**

प्रोग्रामिंग भाषाओं के `break` और `continue` स्टेटमेंट्स के समान, आप लूप से बाहर निकलने का विकल्प चुन सकते हैं, या अगले इटिरेशन पर जारी रख सकते हैं।

### लूप नोड्स में त्रुटियों को संभालना

`v1.4.0-beta` संस्करण से, जब लूप के अंदर कोई नोड निष्पादित होने में विफल रहता है (शर्तें पूरी न होने, त्रुटियों आदि के कारण), तो आप कॉन्फ़िगरेशन के माध्यम से बाद के फ़्लो को निर्धारित कर सकते हैं। तीन हैंडलिंग विधियाँ समर्थित हैं:

*   **वर्कफ़्लो** से बाहर निकलें (प्रोग्रामिंग में `throw` की तरह)
*   लूप से बाहर निकलें और **वर्कफ़्लो** जारी रखें (प्रोग्रामिंग में `break` की तरह)
*   अगले लूप ऑब्जेक्ट पर जारी रखें (प्रोग्रामिंग में `continue` की तरह)

डिफ़ॉल्ट "वर्कफ़्लो से बाहर निकलें" है, जिसे आवश्यकतानुसार बदला जा सकता है।

## उदाहरण

उदाहरण के लिए, जब कोई ऑर्डर दिया जाता है, तो आपको ऑर्डर में प्रत्येक उत्पाद के लिए स्टॉक की जांच करनी होगी। यदि स्टॉक पर्याप्त है, तो स्टॉक घटाएँ; अन्यथा, ऑर्डर विवरण में उत्पाद को अमान्य के रूप में अपडेट करें।

1.  तीन **संग्रह** बनाएँ: उत्पाद <-(1:m)-- ऑर्डर विवरण --(m:1)-> ऑर्डर। **डेटा** मॉडल इस प्रकार है:

    **ऑर्डर संग्रह**
    | फ़ील्ड नाम     | फ़ील्ड प्रकार       |
    | ------------ | -------------- |
    | ऑर्डर विवरण | वन-टू-मेनी (ऑर्डर विवरण) |
    | ऑर्डर कुल मूल्य     | संख्या           |

    **ऑर्डर विवरण संग्रह**
    | फ़ील्ड नाम | फ़ील्ड प्रकार       |
    | -------- | -------------- |
    | उत्पाद     | मेनी-टू-वन (उत्पाद) |
    | मात्रा     | संख्या           |

    **उत्पाद संग्रह**
    | फ़ील्ड नाम | फ़ील्ड प्रकार |
    | -------- | -------- |
    | उत्पाद नाम | सिंगल लाइन टेक्स्ट |
    | मूल्य     | संख्या     |
    | स्टॉक     | पूर्णांक     |

2.  एक **वर्कफ़्लो** बनाएँ। ट्रिगर के लिए, "**संग्रह** इवेंट" चुनें, और "ऑर्डर" **संग्रह** को "रिकॉर्ड जोड़े जाने के बाद" ट्रिगर करने के लिए चुनें। आपको "ऑर्डर विवरण" **संग्रह** और विवरण के तहत उत्पाद **संग्रह** के संबंध **डेटा** को प्रीलोड करने के लिए भी कॉन्फ़िगर करना होगा:

    ![लूप नोड_उदाहरण_ट्रिगर कॉन्फ़िगरेशन](https://static-docs.nocobase.com/0086601c2fc0e17a64d046a4c86b49b7.png)

3.  एक लूप नोड बनाएँ, और लूप ऑब्जेक्ट को "ट्रिगर **डेटा** / ऑर्डर विवरण" के रूप में चुनें, जिसका अर्थ है कि यह ऑर्डर विवरण **संग्रह** में प्रत्येक रिकॉर्ड को प्रोसेस करेगा:

    ![लूप नोड_उदाहरण_लूप नोड कॉन्फ़िगरेशन](https://static-docs.nocobase.com/2507becc32db5a9a0641c198605a20da.png)

4.  लूप नोड के अंदर, एक "कंडीशन" नोड बनाएँ यह जांचने के लिए कि उत्पाद का स्टॉक पर्याप्त है या नहीं:

    ![लूप नोड_उदाहरण_कंडीशन नोड कॉन्फ़िगरेशन](https://static-docs.nocobase.com/a6d08d15786841e1a3512b38e4629852.png)

5.  यदि पर्याप्त है, तो "हाँ" ब्रांच में एक "कैलकुलेशन नोड" और एक "रिकॉर्ड अपडेट करें" नोड बनाएँ गणना किए गए घटाए गए स्टॉक के साथ संबंधित उत्पाद रिकॉर्ड को अपडेट करने के लिए:

    ![लूप नोड_उदाहरण_कैलकुलेशन नोड कॉन्फ़िगरेशन](https://static-docs.nocobase.com/8df3604c71f8f8705b1552d3ebfe3b50.png)

    ![लूप नोड_उदाहरण_स्टॉक अपडेट नोड कॉन्फ़िगरेशन](https://static-docs.nocobase.com/2d84baa9b3b01bd85fccda9eec992378.png)

6.  अन्यथा, "नहीं" ब्रांच में एक "रिकॉर्ड अपडेट करें" नोड बनाएँ ऑर्डर विवरण की स्थिति को "अमान्य" में अपडेट करने के लिए:

    ![लूप नोड_उदाहरण_ऑर्डर विवरण अपडेट नोड कॉन्फ़िगरेशन](https://static-docs.nocobase.com/4996613090c254c69a1d80f3b3a7fae2.png)

कुल **वर्कफ़्लो** संरचना नीचे दी गई है:

![लूप नोड_उदाहरण_वर्कफ़्लो संरचना](https://static-docs.nocobase.com/6f59ef246c1f1997634a7624c4c4151.png)

इस **वर्कफ़्लो** को कॉन्फ़िगर और सक्रिय करने के बाद, जब एक नया ऑर्डर बनाया जाता है, तो यह स्वचालित रूप से ऑर्डर विवरण में उत्पादों के स्टॉक की जांच करेगा। यदि स्टॉक पर्याप्त है, तो इसे घटाया जाएगा; अन्यथा, ऑर्डर विवरण में उत्पाद को अमान्य के रूप में अपडेट किया जाएगा (ताकि एक वैध ऑर्डर कुल मूल्य की गणना की जा सके)।