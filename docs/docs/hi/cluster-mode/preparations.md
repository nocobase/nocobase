:::tip
यह दस्तावेज़ AI द्वारा अनुवादित किया गया है। किसी भी अशुद्धि के लिए, कृपया [अंग्रेजी संस्करण](/en) देखें
:::

# आवश्यक तैयारी

क्लस्टर एप्लिकेशन को डिप्लॉय करने से पहले, आपको निम्नलिखित तैयारी पूरी करनी होगी।

## व्यावसायिक प्लगइन लाइसेंस

NocoBase एप्लिकेशन को क्लस्टर मोड में चलाने के लिए निम्नलिखित प्लगइन के समर्थन की आवश्यकता होती है:

| कार्यक्षमता             | प्लगइन                                                                                |
| ------------------------ | ----------------------------------------------------------------------------------- |
| कैश एडाप्टर            | बिल्ट-इन                                                                            |
| सिंक सिग्नल एडाप्टर      | `@nocobase/plugin-pubsub-adapter-redis`                                             |
| मैसेज क्यू एडाप्टर    | `@nocobase/plugin-queue-adapter-redis` या `@nocobase/plugin-queue-adapter-rabbitmq` |
| डिस्ट्रीब्यूटेड लॉक एडाप्टर | `@nocobase/plugin-lock-adapter-redis`                                               |
| वर्कर आईडी एलोकेटर      | `@nocobase/plugin-workerid-allocator-redis`                                         |

सबसे पहले, कृपया सुनिश्चित करें कि आपने उपरोक्त प्लगइन के लिए लाइसेंस प्राप्त कर लिए हैं (आप व्यावसायिक प्लगइन सेवा प्लेटफॉर्म के माध्यम से संबंधित प्लगइन लाइसेंस खरीद सकते हैं)।

## सिस्टम घटक

एप्लिकेशन इंस्टेंस के अलावा अन्य सिस्टम घटकों को, टीम की ऑपरेशनल ज़रूरतों के अनुसार, ऑपरेशनल कर्मियों द्वारा चुना जा सकता है।

### डेटाबेस

चूंकि वर्तमान क्लस्टर मोड केवल एप्लिकेशन इंस्टेंस को लक्षित करता है, इसलिए डेटाबेस अस्थायी रूप से केवल एक सिंगल नोड का समर्थन करता है। यदि आपके पास मास्टर-स्लेव जैसी डेटाबेस आर्किटेक्चर है, तो आपको इसे मिडलवेयर के माध्यम से स्वयं लागू करना होगा और यह सुनिश्चित करना होगा कि यह NocoBase एप्लिकेशन के लिए पारदर्शी हो।

### मिडलवेयर

NocoBase का क्लस्टर मोड क्लस्टर के बीच संचार और समन्वय प्राप्त करने के लिए कुछ मिडलवेयर पर निर्भर करता है, जिनमें शामिल हैं:

- **कैश**: डेटा एक्सेस की गति बढ़ाने के लिए Redis-आधारित डिस्ट्रीब्यूटेड कैश मिडलवेयर का उपयोग करता है।
- **सिंक सिग्नल**: क्लस्टर के बीच सिंक सिग्नल ट्रांसमिशन को लागू करने के लिए Redis की स्ट्रीम सुविधा का उपयोग करता है।
- **मैसेज क्यू**: एसिंक्रोनस मैसेज प्रोसेसिंग को लागू करने के लिए Redis या RabbitMQ-आधारित मैसेज क्यू मिडलवेयर का उपयोग करता है।
- **डिस्ट्रीब्यूटेड लॉक**: क्लस्टर में साझा संसाधनों तक पहुंच की सुरक्षा सुनिश्चित करने के लिए Redis-आधारित डिस्ट्रीब्यूटेड लॉक का उपयोग करता है।

जब सभी मिडलवेयर Redis का उपयोग करते हैं, तो आप क्लस्टर के आंतरिक नेटवर्क (या Kubernetes) के भीतर एक सिंगल Redis सेवा शुरू कर सकते हैं। वैकल्पिक रूप से, आप प्रत्येक कार्यक्षमता (कैश, सिंक सिग्नल, मैसेज क्यू और डिस्ट्रीब्यूटेड लॉक) के लिए एक अलग Redis सेवा सक्षम कर सकते हैं।

**संस्करण सुझाव**

- Redis: >=8.0 या redis-stack का ऐसा संस्करण जिसमें ब्लूम फ़िल्टर (Bloom Filter) सुविधा शामिल हो।
- RabbitMQ: >=4.0

### साझा स्टोरेज

NocoBase को सिस्टम-संबंधित फ़ाइलों को स्टोर करने के लिए `storage` डायरेक्टरी का उपयोग करने की आवश्यकता होती है। मल्टी-नोड मोड में, आपको मल्टीपल नोड्स में साझा एक्सेस का समर्थन करने के लिए एक क्लाउड डिस्क (या NFS) माउंट करना चाहिए। अन्यथा, लोकल स्टोरेज स्वचालित रूप से सिंक्रनाइज़ नहीं होगा, और यह ठीक से काम नहीं करेगा।

Kubernetes के साथ डिप्लॉय करते समय, कृपया [Kubernetes डिप्लॉयमेंट: साझा स्टोरेज](./kubernetes#shared-storage) अनुभाग देखें।

### लोड बैलेंसिंग

क्लस्टर मोड को अनुरोधों को वितरित करने के साथ-साथ एप्लिकेशन इंस्टेंस के हेल्थ चेक और फेलओवर के लिए एक लोड बैलेंसर की आवश्यकता होती है। इस हिस्से को टीम की ऑपरेशनल ज़रूरतों के अनुसार चुना और कॉन्फ़िगर किया जाना चाहिए।

स्वयं-होस्टेड Nginx के उदाहरण के तौर पर, कॉन्फ़िगरेशन फ़ाइल में निम्नलिखित सामग्री जोड़ें:

```
upstream myapp {
    # ip_hash; # सेशन परसिस्टेंस के लिए उपयोग किया जा सकता है। सक्षम होने पर, एक ही क्लाइंट से आने वाले अनुरोध हमेशा एक ही बैकएंड सर्वर पर भेजे जाते हैं।
    server 172.31.0.1:13000; # आंतरिक नोड 1
    server 172.31.0.2:13000; # आंतरिक नोड 2
    server 172.31.0.3:13000; # आंतरिक नोड 3
}

server {
    listen 80;

    location / {
        # लोड बैलेंसिंग के लिए परिभाषित अपस्ट्रीम का उपयोग करें
        proxy_pass http://myapp;
        # ... अन्य कॉन्फ़िगरेशन
    }
}
```

इसका अर्थ है कि अनुरोधों को रिवर्स-प्रॉक्सी किया जाता है और प्रोसेसिंग के लिए विभिन्न सर्वर नोड्स पर वितरित किया जाता है।

अन्य क्लाउड सेवा प्रदाताओं द्वारा प्रदान किए गए लोड बैलेंसिंग मिडलवेयर के लिए, कृपया विशिष्ट प्रदाता द्वारा प्रदान किए गए कॉन्फ़िगरेशन दस्तावेज़ देखें।

## एनवायरनमेंट वेरिएबल कॉन्फ़िगरेशन

क्लस्टर के भीतर सभी नोड्स को समान एनवायरनमेंट वेरिएबल कॉन्फ़िगरेशन का उपयोग करना चाहिए। NocoBase के बुनियादी [एनवायरनमेंट वेरिएबल](/api/cli/env) के अलावा, निम्नलिखित मिडलवेयर-संबंधित एनवायरनमेंट वेरिएबल को भी कॉन्फ़िगर करने की आवश्यकता है।

### मल्टी-कोर मोड

जब एप्लिकेशन मल्टी-कोर नोड पर चलता है, तो आप नोड के मल्टी-कोर मोड को सक्षम कर सकते हैं:

```ini
# PM2 मल्टी-कोर मोड सक्षम करें
# CLUSTER_MODE=max # डिफ़ॉल्ट रूप से अक्षम है, मैन्युअल कॉन्फ़िगरेशन की आवश्यकता है
```

यदि आप Kubernetes में एप्लिकेशन पॉड डिप्लॉय कर रहे हैं, तो आप इस कॉन्फ़िगरेशन को अनदेखा कर सकते हैं और पॉड रेप्लिका की संख्या के माध्यम से एप्लिकेशन इंस्टेंस की संख्या को नियंत्रित कर सकते हैं।

### कैश

```ini
# कैश एडाप्टर, क्लस्टर मोड में redis के रूप में सेट किया जाना चाहिए (यदि सेट नहीं किया गया तो डिफ़ॉल्ट रूप से इन-मेमोरी)
CACHE_DEFAULT_STORE=redis

# Redis कैश एडाप्टर कनेक्शन URL, भरना आवश्यक है
CACHE_REDIS_URL=
```

### सिंक सिग्नल

```ini
# Redis सिंक एडाप्टर कनेक्शन URL, यदि सेट नहीं किया गया तो डिफ़ॉल्ट रूप से redis://localhost:6379/0
PUBSUB_ADAPTER_REDIS_URL=
```

### डिस्ट्रीब्यूटेड लॉक

```ini
# लॉक एडाप्टर, क्लस्टर मोड में redis के रूप में सेट किया जाना चाहिए (यदि सेट नहीं किया गया तो डिफ़ॉल्ट रूप से इन-मेमोरी लोकल लॉक)
LOCK_ADAPTER_DEFAULT=redis

# Redis लॉक एडाप्टर कनेक्शन URL, यदि सेट नहीं किया गया तो डिफ़ॉल्ट रूप से redis://localhost:6379/0
LOCK_ADAPTER_REDIS_URL=
```

### मैसेज क्यू

```ini
# Redis को मैसेज क्यू एडाप्टर के रूप में सक्षम करें, यदि सेट नहीं किया गया तो डिफ़ॉल्ट रूप से इन-मेमोरी एडाप्टर
QUEUE_ADAPTER=redis
# Redis मैसेज क्यू एडाप्टर कनेक्शन URL, यदि सेट नहीं किया गया तो डिफ़ॉल्ट रूप से redis://localhost:6379/0
QUEUE_ADAPTER_REDIS_URL=
```

### वर्कर आईडी एलोकेटर

NocoBase में कुछ सिस्टम **संग्रह** प्राइमरी की के रूप में ग्लोबली यूनिक आईडी का उपयोग करते हैं। क्लस्टर में प्राइमरी-की के टकराव को रोकने के लिए, प्रत्येक एप्लिकेशन इंस्टेंस को वर्कर आईडी एलोकेटर के माध्यम से एक यूनिक वर्कर आईडी प्राप्त करनी होगी। वर्तमान वर्कर आईडी रेंज 0-31 है, जिसका अर्थ है कि प्रत्येक एप्लिकेशन एक साथ अधिकतम 32 नोड्स चला सकता है। ग्लोबली यूनिक आईडी डिज़ाइन के विवरण के लिए, [@nocobase/snowflake-id](https://github.com/nocobase/nocobase/tree/main/packages/core/snowflake-id) देखें।

```ini
# वर्कर आईडी एलोकेटर के लिए Redis कनेक्शन URL। यदि छोड़ा जाता है, तो एक रैंडम वर्कर आईडी असाइन की जाएगी।
REDIS_URL=
```

:::info{title=टिप}
आमतौर पर, संबंधित एडाप्टर सभी एक ही Redis इंस्टेंस का उपयोग कर सकते हैं, लेकिन संभावित की (key) टकराव की समस्याओं से बचने के लिए विभिन्न डेटाबेस का उपयोग करना सबसे अच्छा है, उदाहरण के लिए:

```ini
CACHE_REDIS_URL=redis://localhost:6379/0
PUBSUB_ADAPTER_REDIS_URL=redis://localhost:6379/1
LOCK_ADAPTER_REDIS_URL=redis://localhost:6379/2
QUEUE_ADAPTER_REDIS_URL=redis://localhost:6379/3
REDIS_URL=redis://localhost:6379/4
```

वर्तमान में, प्रत्येक प्लगइन अपने स्वयं के Redis-संबंधित एनवायरनमेंट वेरिएबल कॉन्फ़िगरेशन का उपयोग करता है। भविष्य में, हम `REDIS_URL` को फ़ॉलबैक कॉन्फ़िगरेशन के रूप में उपयोग करने पर विचार कर सकते हैं।

:::

यदि आप क्लस्टर को प्रबंधित करने के लिए Kubernetes का उपयोग करते हैं, तो आप उपरोक्त एनवायरनमेंट वेरिएबल को ConfigMap या Secret में कॉन्फ़िगर कर सकते हैं। अधिक संबंधित सामग्री के लिए, आप [Kubernetes डिप्लॉयमेंट](./kubernetes) देखें।

उपरोक्त सभी तैयारी पूरी होने के बाद, आप एप्लिकेशन इंस्टेंस को प्रबंधित करना जारी रखने के लिए [ऑपरेशंस](./operations) पर जा सकते हैं।