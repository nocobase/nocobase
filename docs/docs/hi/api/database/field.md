:::tip
यह दस्तावेज़ AI द्वारा अनुवादित किया गया है। किसी भी अशुद्धि के लिए, कृपया [अंग्रेजी संस्करण](/en) देखें
:::

# फ़ील्ड

## अवलोकन

यह संग्रह फ़ील्ड प्रबंधन क्लास (एब्स्ट्रैक्ट क्लास) है। यह सभी फ़ील्ड प्रकारों के लिए बेस क्लास भी है। कोई भी अन्य फ़ील्ड प्रकार इस क्लास को इनहेरिट करके लागू किया जाता है।

फ़ील्ड को कैसे कस्टमाइज़ करें, इसके लिए [फ़ील्ड प्रकारों का विस्तार करें] देखें।

## कंस्ट्रक्टर

इसे आमतौर पर डेवलपर्स द्वारा सीधे कॉल नहीं किया जाता है, बल्कि मुख्य रूप से `db.collection({ fields: [] })` मेथड के माध्यम से एक प्रॉक्सी एंट्री पॉइंट के रूप में कॉल किया जाता है।

किसी फ़ील्ड का विस्तार करते समय, इसे मुख्य रूप से `Field` एब्स्ट्रैक्ट क्लास को इनहेरिट करके और फिर इसे डेटाबेस इंस्टेंस में रजिस्टर करके लागू किया जाता है।

**सिग्नेचर**

- `constructor(options: FieldOptions, context: FieldContext)`

**पैरामीटर्स**

| पैरामीटर            | प्रकार           | डिफ़ॉल्ट मान | विवरण                                     |
| -------------------- | -------------- | ------ | ---------------------------------------- |
| `options`            | `FieldOptions` | -      | फ़ील्ड कॉन्फ़िगरेशन ऑब्जेक्ट              |
| `options.name`       | `string`       | -      | फ़ील्ड का नाम                             |
| `options.type`       | `string`       | -      | फ़ील्ड का प्रकार, जो db में रजिस्टर्ड फ़ील्ड प्रकार के नाम से मेल खाता है |
| `context`            | `FieldContext` | -      | फ़ील्ड कॉन्टेक्स्ट ऑब्जेक्ट                |
| `context.database`   | `Database`     | -      | डेटाबेस इंस्टेंस                          |
| `context.collection` | `Collection`   | -      | संग्रह इंस्टेंस                           |

## इंस्टेंस सदस्य

### `name`

फ़ील्ड का नाम।

### `type`

फ़ील्ड का प्रकार।

### `dataType`

फ़ील्ड का डेटाबेस स्टोरेज प्रकार।

### `options`

फ़ील्ड इनिशियलाइज़ेशन कॉन्फ़िगरेशन पैरामीटर्स।

### `context`

फ़ील्ड कॉन्टेक्स्ट ऑब्जेक्ट।

## कॉन्फ़िगरेशन मेथड्स

### `on()`

संग्रह इवेंट्स पर आधारित एक शॉर्टकट परिभाषा मेथड। यह `db.on(this.collection.name + '.' + eventName, listener)` के बराबर है।

इनहेरिट करते समय आमतौर पर इस मेथड को ओवरराइड करने की आवश्यकता नहीं होती है।

**सिग्नेचर**

- `on(eventName: string, listener: (...args: any[]) => void)`

**पैरामीटर्स**

| पैरामीटर    | प्रकार                       | डिफ़ॉल्ट मान | विवरण       |
| ----------- | -------------------------- | ------ | ---------- |
| `eventName` | `string`                   | -      | इवेंट का नाम   |
| `listener`  | `(...args: any[]) => void` | -      | इवेंट लिसनर |

### `off()`

संग्रह इवेंट्स पर आधारित एक शॉर्टकट हटाने की मेथड। यह `db.off(this.collection.name + '.' + eventName, listener)` के बराबर है।

इनहेरिट करते समय आमतौर पर इस मेथड को ओवरराइड करने की आवश्यकता नहीं होती है।

**सिग्नेचर**

- `off(eventName: string, listener: (...args: any[]) => void)`

**पैरामीटर्स**

| पैरामीटर    | प्रकार                       | डिफ़ॉल्ट मान | विवरण       |
| ----------- | -------------------------- | ------ | ---------- |
| `eventName` | `string`                   | -      | इवेंट का नाम   |
| `listener`  | `(...args: any[]) => void` | -      | इवेंट लिसनर |

### `bind()`

जब किसी फ़ील्ड को संग्रह में जोड़ा जाता है तो निष्पादित होने वाली सामग्री। इसका उपयोग आमतौर पर संग्रह इवेंट लिसनर और अन्य प्रोसेसिंग जोड़ने के लिए किया जाता है।

इनहेरिट करते समय, आपको पहले संबंधित `super.bind()` मेथड को कॉल करना होगा।

**सिग्नेचर**

- `bind()`

### `unbind()`

जब किसी फ़ील्ड को संग्रह से हटाया जाता है तो निष्पादित होने वाली सामग्री। इसका उपयोग आमतौर पर संग्रह इवेंट लिसनर और अन्य प्रोसेसिंग को हटाने के लिए किया जाता है।

इनहेरिट करते समय, आपको पहले संबंधित `super.unbind()` मेथड को कॉल करना होगा।

**सिग्नेचर**

- `unbind()`

### `get()`

किसी फ़ील्ड के कॉन्फ़िगरेशन आइटम का मान प्राप्त करता है।

**सिग्नेचर**

- `get(key: string): any`

**पैरामीटर्स**

| पैरामीटर | प्रकार     | डिफ़ॉल्ट मान | विवरण       |
| ------ | -------- | ------ | ---------- |
| `key`  | `string` | -      | कॉन्फ़िगरेशन आइटम का नाम |

**उदाहरण**

```ts
const field = db.collection('users').getField('name');

// फ़ील्ड नाम कॉन्फ़िगरेशन आइटम का मान प्राप्त करें, 'name' लौटाता है
console.log(field.get('name'));
```

### `merge()`

किसी फ़ील्ड के कॉन्फ़िगरेशन आइटम के मानों को मर्ज करता है।

**सिग्नेचर**

- `merge(options: { [key: string]: any }): void`

**पैरामीटर्स**

| पैरामीटर  | प्रकार                     | डिफ़ॉल्ट मान | विवरण               |
| --------- | ------------------------ | ------ | ------------------ |
| `options` | `{ [key: string]: any }` | -      | मर्ज किए जाने वाले कॉन्फ़िगरेशन आइटम का ऑब्जेक्ट |

**उदाहरण**

```ts
const field = db.collection('users').getField('name');

field.merge({
  // एक इंडेक्स कॉन्फ़िगरेशन जोड़ें
  index: true,
});
```

### `remove()`

संग्रह से फ़ील्ड हटाता है (केवल मेमोरी से हटाता है)।

**उदाहरण**

```ts
const books = db.getCollections('books');

books.getField('isbn').remove();

// डेटाबेस से वास्तव में हटाएँ
await books.sync();
```

## डेटाबेस मेथड्स

### `removeFromDb()`

डेटाबेस से फ़ील्ड हटाता है।

**सिग्नेचर**

- `removeFromDb(options?: Transactionable): Promise<void>`

**पैरामीटर्स**

| पैरामीटर               | प्रकार          | डिफ़ॉल्ट मान | विवरण     |
| ---------------------- | ------------- | ------ | -------- |
| `options.transaction?` | `Transaction` | -      | ट्रांज़ैक्शन इंस्टेंस |

### `existsInDb()`

निर्धारित करता है कि फ़ील्ड डेटाबेस में मौजूद है या नहीं।

**सिग्नेचर**

- `existsInDb(options?: Transactionable): Promise<boolean>`

**पैरामीटर्स**

| पैरामीटर               | प्रकार          | डिफ़ॉल्ट मान | विवरण     |
| ---------------------- | ------------- | ------ | -------- |
| `options.transaction?` | `Transaction` | -      | ट्रांज़ैक्शन इंस्टेंस |

## बिल्ट-इन फ़ील्ड प्रकारों की सूची

NocoBase में कुछ सामान्य रूप से उपयोग किए जाने वाले फ़ील्ड प्रकार बिल्ट-इन हैं, और आप संग्रह के लिए फ़ील्ड परिभाषित करते समय सीधे संबंधित प्रकार के नाम का उपयोग करके प्रकार निर्दिष्ट कर सकते हैं। विभिन्न प्रकार के फ़ील्ड में अलग-अलग पैरामीटर कॉन्फ़िगरेशन होते हैं, कृपया विवरण के लिए नीचे दी गई सूची देखें।

फ़ील्ड प्रकारों के लिए सभी कॉन्फ़िगरेशन आइटम, नीचे बताए गए अतिरिक्त आइटमों को छोड़कर, Sequelize में पास किए जाएंगे, इसलिए Sequelize द्वारा समर्थित सभी फ़ील्ड कॉन्फ़िगरेशन आइटम यहां उपयोग किए जा सकते हैं (जैसे `allowNull`, `defaultValue`, आदि)।

इसके अलावा, सर्वर-साइड फ़ील्ड प्रकार मुख्य रूप से डेटाबेस स्टोरेज और कुछ एल्गोरिदम की समस्याओं को हल करते हैं, और फ्रंट-एंड फ़ील्ड डिस्प्ले प्रकारों और उपयोग किए गए कंपोनेंट्स से मूल रूप से असंबंधित हैं। फ्रंट-एंड फ़ील्ड प्रकारों के लिए, कृपया संबंधित ट्यूटोरियल निर्देशों का संदर्भ लें।

### `'boolean'`

बूलियन मान प्रकार।

**उदाहरण**

```js
db.collection({
  name: 'books',
  fields: [
    {
      type: 'boolean',
      name: 'published',
    },
  ],
});
```

### `'integer'`

पूर्णांक प्रकार (32-बिट)।

**उदाहरण**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'integer',
      name: 'pages',
    },
  ],
});
```

### `'bigInt'`

बड़ा पूर्णांक प्रकार (64-बिट)।

**उदाहरण**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'bigInt',
      name: 'words',
    },
  ],
});
```

### `'double'`

डबल-प्रिसिजन फ़्लोटिंग-पॉइंट प्रकार (64-बिट)।

**उदाहरण**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'double',
      name: 'price',
    },
  ],
});
```

### `'real'`

वास्तविक संख्या प्रकार (केवल PG के लिए)।

### `'decimal'`

दशमलव संख्या प्रकार।

### `'string'`

स्ट्रिंग प्रकार। अधिकांश डेटाबेस में `VARCHAR` प्रकार के बराबर।

**उदाहरण**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'string',
      name: 'title',
    },
  ],
});
```

### `'text'`

टेक्स्ट प्रकार। अधिकांश डेटाबेस में `TEXT` प्रकार के बराबर।

**उदाहरण**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'text',
      name: 'content',
    },
  ],
});
```

### `'password'`

पासवर्ड प्रकार (NocoBase एक्सटेंशन)। Node.js के नेटिव क्रिप्टो पैकेज के `scrypt` मेथड के आधार पर पासवर्ड एन्क्रिप्ट करता है।

**उदाहरण**

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'password',
      name: 'password',
      length: 64, // लंबाई, डिफ़ॉल्ट 64
      randomBytesSize: 8, // रैंडम बाइट लंबाई, डिफ़ॉल्ट 8
    },
  ],
});
```

**पैरामीटर्स**

| पैरामीटर         | प्रकार     | डिफ़ॉल्ट मान | विवरण         |
| ----------------- | -------- | ------ | ------------ |
| `length`          | `number` | 64     | अक्षर की लंबाई |
| `randomBytesSize` | `number` | 8      | रैंडम बाइट का आकार |

### `'date'`

दिनांक प्रकार।

### `'time'`

समय प्रकार।

### `'array'`

ऐरे प्रकार (केवल PG के लिए)।

### `'json'`

JSON प्रकार।

### `'jsonb'`

JSONB प्रकार (केवल PG के लिए, अन्य को `'json'` प्रकार के रूप में संगत किया जाएगा)।

### `'uuid'`

UUID प्रकार।

### `'uid'`

UID प्रकार (NocoBase एक्सटेंशन)। छोटा रैंडम स्ट्रिंग आइडेंटिफ़ायर प्रकार।

### `'formula'`

फ़ॉर्मूला प्रकार (NocoBase एक्सटेंशन)। [mathjs](https://www.npmjs.com/package/mathjs) पर आधारित गणितीय फ़ॉर्मूला गणनाओं को कॉन्फ़िगर करने की अनुमति देता है। फ़ॉर्मूला गणना के लिए उसी रिकॉर्ड में अन्य कॉलम के मानों को संदर्भित कर सकता है।

**उदाहरण**

```ts
db.collection({
  name: 'orders',
  fields: [
    {
      type: 'double',
      name: 'price',
    },
    {
      type: 'integer',
      name: 'quantity',
    },
    {
      type: 'formula',
      name: 'total',
      expression: 'price * quantity',
    },
  ],
});
```

### `'radio'`

रेडियो प्रकार (NocoBase एक्सटेंशन)। पूरे संग्रह में अधिकतम एक पंक्ति के डेटा में इस फ़ील्ड का मान `true` हो सकता है; अन्य सभी `false` या `null` होंगे।

**उदाहरण**

पूरे सिस्टम में केवल एक उपयोगकर्ता को रूट के रूप में चिह्नित किया गया है। किसी अन्य उपयोगकर्ता के रूट मान को `true` में बदलने के बाद, रूट के रूप में `true` वाले अन्य सभी रिकॉर्ड को `false` में बदल दिया जाएगा:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'radio',
      name: 'root',
    },
  ],
});
```

### `'sort'`

सॉर्ट प्रकार (NocoBase एक्सटेंशन)। पूर्णांक संख्याओं के आधार पर सॉर्ट करता है, नए रिकॉर्ड के लिए स्वचालित रूप से एक नया अनुक्रम संख्या उत्पन्न करता है, और डेटा को स्थानांतरित करने पर अनुक्रम संख्याओं को पुनर्व्यवस्थित करता है।

यदि किसी संग्रह में `sortable` विकल्प परिभाषित है, तो एक संबंधित फ़ील्ड भी स्वचालित रूप से उत्पन्न होगा।

**उदाहरण**

पोस्ट को उस उपयोगकर्ता के आधार पर सॉर्ट किया जा सकता है जिससे वे संबंधित हैं:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsTo',
      name: 'user',
    },
    {
      type: 'sort',
      name: 'priority',
      scopeKey: 'userId', // समान userId मान द्वारा समूहीकृत डेटा को सॉर्ट करें
    },
  ],
});
```

### `'virtual'`

वर्चुअल प्रकार। वास्तव में डेटा संग्रहीत नहीं करता है, केवल विशेष getter/setter परिभाषाओं के लिए उपयोग किया जाता है।

### `'belongsTo'`

कई-से-एक संबंध प्रकार। फ़ॉरेन की अपनी तालिका में संग्रहीत होती है, जो hasOne/hasMany के विपरीत है।

**उदाहरण**

कोई भी पोस्ट किसी लेखक से संबंधित होती है:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsTo',
      name: 'author',
      target: 'users', // यदि कॉन्फ़िगर नहीं किया गया है, तो यह डिफ़ॉल्ट रूप से संग्रह के नाम के बहुवचन रूप का उपयोग करता है
      foreignKey: 'authorId', // यदि कॉन्फ़िगर नहीं किया गया है, तो यह डिफ़ॉल्ट रूप से `<name> + Id` फ़ॉर्मेट का उपयोग करता है
      sourceKey: 'id', // यदि कॉन्फ़िगर नहीं किया गया है, तो यह डिफ़ॉल्ट रूप से टारगेट संग्रह की id का उपयोग करता है
    },
  ],
});
```

### `'hasOne'`

एक-से-एक संबंध प्रकार। फ़ॉरेन की संबंधित संग्रह में संग्रहीत होती है, जो belongsTo के विपरीत है।

**उदाहरण**

प्रत्येक उपयोगकर्ता की एक प्रोफ़ाइल होती है:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'hasOne',
      name: 'profile',
      target: 'profiles', // छोड़ा जा सकता है
    },
  ],
});
```

### `'hasMany'`

एक-से-कई संबंध प्रकार। फ़ॉरेन की संबंधित संग्रह में संग्रहीत होती है, जो belongsTo के विपरीत है।

**उदाहरण**

कोई भी उपयोगकर्ता कई पोस्ट रख सकता है:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'hasMany',
      name: 'posts',
      foreignKey: 'authorId',
      sourceKey: 'id',
    },
  ],
});
```

### `'belongsToMany'`

कई-से-कई संबंध प्रकार। दोनों पक्षों की फ़ॉरेन की को संग्रहीत करने के लिए एक मध्यवर्ती संग्रह का उपयोग करता है। यदि किसी मौजूदा संग्रह को मध्यवर्ती संग्रह के रूप में निर्दिष्ट नहीं किया जाता है, तो एक मध्यवर्ती संग्रह स्वचालित रूप से बनाया जाएगा।

**उदाहरण**

कोई भी पोस्ट कई टैग रख सकता है, और किसी भी टैग को कई पोस्ट में जोड़ा जा सकता है:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsToMany',
      name: 'tags',
      target: 'tags', // यदि नाम समान है तो छोड़ा जा सकता है
      through: 'postsTags', // यदि कॉन्फ़िगर नहीं किया गया है तो मध्यवर्ती संग्रह स्वचालित रूप से उत्पन्न होगा
      foreignKey: 'postId', // मध्यवर्ती संग्रह में स्रोत संग्रह की फ़ॉरेन की
      sourceKey: 'id', // स्रोत संग्रह की प्राइमरी की
      otherKey: 'tagId', // मध्यवर्ती संग्रह में टारगेट संग्रह की फ़ॉरेन की
    },
  ],
});

db.collection({
  name: 'tags',
  fields: [
    {
      type: 'belongsToMany',
      name: 'posts',
      through: 'postsTags', // संबंधों का एक ही समूह एक ही मध्यवर्ती संग्रह को इंगित करता है
    },
  ],
});
```