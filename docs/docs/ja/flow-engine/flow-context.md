
:::tip
このドキュメントはAIによって翻訳されました。不正確な情報については、[英語版](/en)をご参照ください
:::


# コンテキストシステム概要
NocoBaseのワークフローエンジンにおけるコンテキストシステムは3つの階層に分かれており、それぞれ異なるスコープに対応しています。これを適切に活用することで、サービス、設定、データの柔軟な共有と分離を実現でき、ビジネスの保守性と拡張性が向上します。

- **FlowEngineContext（グローバルコンテキスト）**：グローバルで一意であり、すべてのモデルやフローからアクセス可能です。グローバルなサービスや設定の登録などに適しています。
- **FlowModelContext（モデルコンテキスト）**：モデルツリー内部でコンテキストを共有するために使用されます。子モデルは親モデルのコンテキストを自動的に委譲（デリゲート）し、同名での上書きもサポートしています。モデルレベルのロジックやデータの分離に適しています。
- **FlowRuntimeContext（フロー実行時コンテキスト）**：フローが実行されるたびに作成され、フローの実行サイクル全体を通して存続します。フロー内のデータ受け渡し、変数保存、実行状態の記録などに適しています。`mode: 'runtime' | 'settings'` の2つのモードをサポートしており、それぞれ実行時モードと設定時モードに対応しています。

これらすべての `FlowEngineContext`（グローバルコンテキスト）、`FlowModelContext`（モデルコンテキスト）、`FlowRuntimeContext`（フロー実行時コンテキスト）などは、`FlowContext` のサブクラスまたはインスタンスです。

---

## 🗂️ 階層構造図

```text
FlowEngineContext（グローバルコンテキスト）
│
├── FlowModelContext（モデルコンテキスト）
│     ├── 子 FlowModelContext（子モデル）
│     │     ├── FlowRuntimeContext（フロー実行時コンテキスト）
│     │     └── FlowRuntimeContext（フロー実行時コンテキスト）
│     └── FlowRuntimeContext（フロー実行時コンテキスト）
│
├── FlowModelContext（モデルコンテキスト）
│     └── FlowRuntimeContext（フロー実行時コンテキスト）
│
└── FlowModelContext（モデルコンテキスト）
      ├── 子 FlowModelContext（子モデル）
      │     └── FlowRuntimeContext（フロー実行時コンテキスト）
      └── FlowRuntimeContext（フロー実行時コンテキスト）
```

- `FlowModelContext` は、デリゲート（委譲）メカニズムを通じて `FlowEngineContext` のプロパティやメソッドにアクセスでき、グローバルな機能共有を実現します。
- 子モデルの `FlowModelContext` は、デリゲート（委譲）メカニズムを通じて親モデルのコンテキスト（同期関係）にアクセスでき、同名での上書きをサポートしています。
- 非同期の親子モデルは、状態汚染を避けるため、デリゲート（委譲）関係を確立しません。
- `FlowRuntimeContext` は常に、デリゲート（委譲）メカニズムを通じて対応する `FlowModelContext` にアクセスしますが、上位に伝播することはありません。

## 🧭 実行時モードと設定時モード（mode）

`FlowRuntimeContext` は2つのモードをサポートしており、`mode` パラメータで区別されます。

- `mode: 'runtime'`（実行時モード）：フローの実際の実行段階で使用されます。プロパティやメソッドは実際のデータを返します。例えば：
  ```js
  console.log(runtimeCtx.steps.step1.result); // 42
  ```

- `mode: 'settings'`（設定時モード）：フローの設計および設定段階で使用されます。プロパティにアクセスすると、変数テンプレート文字列が返されます。これにより、式や変数の選択が容易になります。例えば：
  ```js
  console.log(settingsCtx.steps.step1.result); // '{{ ctx.steps.step1.result }}'
  ```

このデュアルモード設計は、実行時のデータ可用性を保証するだけでなく、設定時の変数参照や式生成も容易にします。これにより、ワークフローエンジンの柔軟性と使いやすさが向上します。