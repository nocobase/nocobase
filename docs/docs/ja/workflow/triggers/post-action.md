---
pkg: '@nocobase/plugin-workflow-action-trigger'
---
:::tip
このドキュメントはAIによって翻訳されました。不正確な情報については、[英語版](/en)をご参照ください
:::


# 操作後イベント

## はじめに

システム内でユーザーが行うすべてのデータ変更は、通常、何らかの操作を通じて行われます。具体的には、フォームの「送信」ボタンやデータブロック内の「操作」ボタンなどのクリックが一般的です。操作後イベントは、これらのボタン操作に**ワークフロー**を紐付け、ユーザーの操作が成功した後に特定のプロセスをトリガーするために使用されます。

例えば、データの新規作成や更新を行う際、ユーザーはボタンの「**ワークフロー**を紐付ける」オプションを設定することで、操作完了後に紐付けられた**ワークフロー**をトリガーできます。

実装レベルでは、操作後イベントの処理はミドルウェア層（Koaのミドルウェア）で行われるため、NocoBaseへのHTTP APIコールによっても、定義済みの操作後イベントをトリガーすることが可能です。

## インストール

これは組み込みの**プラグイン**なので、インストールは不要です。

## トリガー設定

### **ワークフロー**の作成

**ワークフロー**を作成する際、タイプとして「操作後イベント」を選択します。

![ワークフローの作成_操作後イベントトリガー](https://static-docs.nocobase.com/13c87035ec1bb7332514676d3e896007.png)

### 実行モード

操作後イベントの場合、作成時に実行モードを「同期」または「非同期」から選択できます。

![ワークフローの作成_同期または非同期の選択](https://static-docs.nocobase.com/bc83525c7e539d578f9e2e20baf9ab69.png)

ユーザー操作後すぐに実行し、結果を返す必要があるプロセスであれば、同期モードを使用できます。それ以外の場合は、デフォルトで非同期モードになります。非同期モードでは、**ワークフロー**がトリガーされた後、その操作はすぐに完了し、**ワークフロー**はアプリケーションのバックグラウンドでキューとして順次実行されます。

### **コレクション**の設定

**ワークフロー**キャンバスに入り、トリガーをクリックして設定ポップアップを開きます。まず、紐付ける**コレクション**を選択する必要があります。

![ワークフロー設定_コレクションの選択](https://static-docs.nocobase.com/35c49a91eba731127edcf76719c97634.png)

### トリガーモードの選択

次に、トリガーモードを選択します。これには「ローカルモード」と「グローバルモード」の2種類があります。

![ワークフロー設定_トリガーモードの選択](https://static-docs.nocobase.com/317809c48b2f2a2d38aedc7d08abdadc.png)

各モードの詳細は以下の通りです。

*   ローカルモードは、この**ワークフロー**が紐付けられた操作ボタンでのみトリガーされます。この**ワークフロー**が紐付けられていないボタンをクリックしてもトリガーされません。用途の異なるフォームで同じプロセスをトリガーするかどうかを考慮し、この**ワークフロー**を紐付けるかどうかを決定できます。
*   グローバルモードは、**コレクション**に設定されているすべての操作ボタンでトリガーされます。どのフォームからの操作であるかを区別せず、対応する**ワークフロー**を紐付ける必要もありません。

ローカルモードで現在紐付けがサポートされている操作ボタンは以下の通りです。

*   新規作成フォームの「送信」ボタンと「保存」ボタン。
*   更新フォームの「送信」ボタンと「保存」ボタン。
*   データ行（テーブル、リスト、カンバンなど）の「データを更新」ボタン。

### 操作タイプの選択

グローバルモードを選択した場合、操作タイプも選択する必要があります。現在、「データ作成操作」と「データ更新操作」がサポートされています。どちらの操作も、成功後に**ワークフロー**をトリガーします。

### 関連データのプリロードの選択

後続のプロセスでトリガーされたデータの関連データを使用する必要がある場合、プリロードする関連フィールドを選択できます。

![ワークフロー設定_関連データのプリロード](https://static-docs.nocobase.com/5cded063509c7ba1d34f49bec8d68227.png)

トリガー後、これらの関連データをプロセス内で直接使用できます。

## 操作設定

ローカルトリガーモードの操作の場合、**ワークフロー**の設定が完了したら、ユーザーインターフェースに戻り、対応するデータブロックのフォーム操作ボタンに、この**ワークフロー**を紐付ける必要があります。

「送信」ボタン（「データを保存」ボタンを含む）に設定された**ワークフロー**は、ユーザーが対応するフォームを送信し、データ操作が完了した後にトリガーされます。

![操作後イベント_送信ボタン](https://static-docs.nocobase.com/ae12d219b8400d75b395880ec4cb2bda.png)

ボタン設定のメニューから「**ワークフロー**を紐付ける」を選択すると、紐付け設定ポップアップが開きます。このポップアップでは、トリガーする**ワークフロー**を複数設定できます。何も設定しない場合は、トリガーは不要であることを意味します。各**ワークフロー**について、まずトリガーするデータがフォーム全体のデータなのか、それともフォーム内の特定の関連フィールドのデータなのかを限定する必要があります。その後、選択したデータモデルに対応する**コレクション**に基づいて、その**コレクション**モデルに一致するように設定されたフォーム**ワークフロー**を選択します。

![操作後イベント_ワークフロー紐付け設定_コンテキスト選択](https://static-docs.nocobase.com/358315fc175849a7fbadbe3276ac6fed.png)

![操作後イベント_ワークフロー紐付け設定_ワークフロー選択](https://static-docs.nocobase.com/175a71a61b93540cce62a1cb124eb0b5.png)

:::info{title="ヒント"}
**ワークフロー**は、有効化されて初めて上記のインターフェースで選択できるようになります。
:::

## 例

ここでは、新規作成操作を例にデモンストレーションを行います。

「経費精算申請」のシナリオを想定します。従業員が経費精算を申請した後、金額の自動承認と、上限額を超えた場合の手動承認を行います。承認された申請のみが通過し、その後、財務部門で処理されるという流れです。

まず、「経費精算」**コレクション**を作成します。以下のフィールドを持ちます。

*   プロジェクト名：単一行テキスト
*   申請者：多対一（ユーザー）
*   金額：数値
*   ステータス：単一選択（「承認済み」、「処理完了」）

次に、「操作後イベント」タイプの**ワークフロー**を作成し、トリガー内の**コレクション**モデルを「経費精算」**コレクション**に設定します。

![例_トリガー設定_コレクションの選択](https://static-docs.nocobase.com/6e1abb5c3e1198038676115943714f07.png)

**ワークフロー**を有効な状態に設定した後、プロセスの具体的な処理ノードは後で設定します。

次に、インターフェース上に「経費精算」**コレクション**のテーブルブロックを作成し、ツールバーに「追加」ボタンを追加して、対応するフォームフィールドを設定します。そして、フォームの「送信」操作ボタンの設定項目で、ボタンの「**ワークフロー**を紐付ける」設定ダイアログを開き、コンテキストとしてフォーム全体のデータを選択し、**ワークフロー**として以前作成した**ワークフロー**を選択します。

![例_フォームボタン設定_ワークフローの紐付け](https://static-docs.nocobase.com/fc00bdcdb975bb8850e5cab235f854f3.png)

フォームの設定が完了したら、**ワークフロー**のロジック設計に戻ります。例えば、金額が500元を超える場合は管理者に手動承認を要求し、そうでない場合は直接承認します。承認後に経費精算記録を作成し、財務部門でさらに処理されるという流れです（省略）。

![例_処理フロー](https://static-docs.nocobase.com/059e8e3d5ffb34cc2da6880fa3dc490b.png)

後続の財務処理を省略すると、これで経費精算申請プロセスの設定が完了です。従業員が経費精算申請を記入して送信すると、対応する**ワークフロー**がトリガーされます。費用金額が500未満の場合は、自動的に記録が作成され、財務部門でのさらなる処理を待ちます。そうでない場合は、上長による承認が行われ、承認後も同様に記録が作成され、財務部門に引き渡されます。

この例のプロセスは、通常の「送信」ボタンにも設定できます。具体的なビジネスシナリオに応じて、まず記録を作成してから後続のプロセスを実行する必要があるかどうかを決定できます。

## 外部からの呼び出し

操作後イベントのトリガーは、ユーザーインターフェースからの操作に限定されず、HTTP APIコールによってもトリガーできます。

:::info{title="ヒント"}
HTTP APIコールを通じて操作後イベントをトリガーする場合、**ワークフロー**の有効化状態に注意し、**コレクション**の設定が一致しているかどうかも確認する必要があります。そうしないと、呼び出しが成功しないか、エラーが発生する可能性があります。
:::

操作ボタンにローカルで紐付けられた**ワークフロー**の場合、次のように呼び出すことができます（`posts` **コレクション**の作成ボタンを例に）。

```bash
curl -X POST -H 'Authorization: Bearer <your token>' -H 'X-Role: <roleName>' -d \
  '{
    "title": "Hello, world!",
    "content": "This is a test post."
  }'
  "http://localhost:3000/api/posts:create?triggerWorkflows=workflowKey"
```

ここで、URLパラメータ `triggerWorkflows` は**ワークフロー**のキーであり、複数の**ワークフロー**はコンマで区切ります。このキーは、**ワークフロー**キャンバス上部の**ワークフロー**名にマウスカーソルを合わせると取得できます。

![ワークフロー_キー_表示方法](https://static-docs.nocobase.com/20240426135108.png)

上記の呼び出しが成功すると、対応する `posts` **コレクション**の操作後イベントがトリガーされます。

:::info{title="ヒント"}
外部からの呼び出しもユーザーのIDに基づく必要があるため、HTTP APIを通じて呼び出す際は、通常のインターフェースから送信されるリクエストと同様に、認証情報を提供する必要があります。これには、`Authorization` リクエストヘッダーまたは `token` パラメータ（ログイン時に取得したトークン）、および `X-Role` リクエストヘッダー（ユーザーの現在のロール名）が含まれます。
:::

この操作で一対一の関連データ（多対多は現在未サポート）のイベントをトリガーする必要がある場合、パラメータで `!` を使用して、関連フィールドのトリガーデータを指定できます。

```bash
curl -X POST -H 'Authorization: Bearer <your token>' -H 'X-Role: <roleName>' -d \
  '{
    "title": "Hello, world!",
    "content": "This is a test post.",
    "category": {
      "title": "Test category"
    }
  }'
  "http://localhost:3000/api/posts:create?triggerWorkflows=workflowKey!category"
```

上記の呼び出しが成功すると、対応する `categories` **コレクション**の操作後イベントがトリガーされます。

:::info{title="ヒント"}
イベントがグローバルモードに設定されている場合、URLパラメータ `triggerWorkflows` を使用して対応する**ワークフロー**を指定する必要はありません。対応する**コレクション**操作を直接呼び出すだけでトリガーされます。
:::

## よくある質問

### 操作前イベントとの違い

*   操作前イベント：ある操作（新規作成、更新など）が実行される前にトリガーされます。操作実行前、プロセス内でリクエストされたデータの検証や処理を行うことができます。プロセスが中断された場合（リクエストがインターセプトされた場合）、その操作（新規作成、更新など）は実行されません。
*   操作後イベント：ユーザーの操作が成功した後にトリガーされます。この時点ではデータはすでに正常に送信され、データベースに保存されており、成功した結果に基づいて関連するプロセスを継続して処理できます。

下図の通りです。

![操作実行順序](https://static-docs.nocobase.com/7c901be2282067d785205b70391332b7.png)

### **コレクション**イベントとの違い

操作後イベントと**コレクション**イベントには類似点があり、効果としてはどちらもデータ変更後にトリガーされるプロセスです。しかし、実装レベルはそれぞれ異なります。操作後イベントはAPIレベルを対象としており、**コレクション**イベントは**コレクション**のデータ変更を対象としています。

**コレクション**イベントはシステムのより下層に近く、ある状況では、あるイベントによるデータ変更が別のイベントをトリガーし、連鎖反応を引き起こす可能性があります。特に、一部の関連**コレクション**のデータが現在の**コレクション**の操作中に変更された場合、関連**コレクション**に関するイベントもトリガーされることがあります。

**コレクション**イベントのトリガーには、ユーザー関連の情報は含まれません。一方、操作後イベントはユーザーエンドに近く、ユーザー操作の結果です。プロセスのコンテキストにはユーザー関連の情報も含まれるため、ユーザー操作に関連するプロセスを処理するのに適しています。NocoBaseの将来の設計では、トリガーに使用できる操作後イベントがさらに拡張される可能性があります。したがって、ユーザー操作によるデータ変更のプロセスを処理するには、**操作後イベントの使用を強く推奨します**。

もう一つの違いは、操作後イベントは特定のフォームボタンにローカルで紐付けることができる点です。複数のフォームがある場合、一部のフォームの送信でこのイベントをトリガーし、他のフォームではトリガーしないように設定できます。一方、**コレクション**イベントは**コレクション**全体のデータ変更を対象とするため、ローカルで紐付けることはできません。