:::tip Уведомление о переводе ИИ
Эта документация была автоматически переведена ИИ.
:::

## Форматировщики

Форматировщики используются для преобразования исходных данных в удобочитаемый текст. Они применяются к данным с помощью двоеточия (:) и могут быть объединены в цепочку, так что вывод каждого форматировщика становится входом для следующего. Некоторые форматировщики поддерживают константные или динамические параметры.

### Обзор

#### 1. Описание синтаксиса
Базовый вызов форматировщика выглядит следующим образом:
```
{d.property:formatter1:formatter2(...)}
```  
Например, чтобы преобразовать строку `"JOHN"` в `"John"`, сначала используется форматировщик `lowerCase` для перевода всех букв в нижний регистр, а затем `ucFirst` для написания первой буквы с заглавной.

#### 2. Пример
Данные:
```json
{
  "name": "JOHN",
  "birthday": "2000-01-31"
}
```
Шаблон:
```
My name is {d.name:lowerCase:ucFirst}. I was born on {d.birthday:formatD(LL)}.
```

#### 3. Результат
После рендеринга вывод будет следующим:
```
My name is John. I was born on January 31, 2000.
```

### Константные параметры

#### 1. Описание синтаксиса
Многие форматировщики поддерживают один или несколько константных параметров, которые разделяются запятыми и заключаются в круглые скобки для изменения вывода. Например, `:prepend(myPrefix)` добавит "myPrefix" перед текстом.  
**Обратите внимание:** Если параметр содержит запятые или пробелы, его необходимо заключить в одинарные кавычки, например: `prepend('my prefix')`.

#### 2. Пример
Пример шаблона (подробности см. в описании конкретного форматировщика).

#### 3. Результат
Вывод будет содержать указанный префикс перед текстом.

### Динамические параметры

#### 1. Описание синтаксиса
Форматировщики также поддерживают динамические параметры. Эти параметры начинаются с точки (`.`) и не заключаются в кавычки.  
Доступны два способа указания динамических параметров:
- **Абсолютный JSON-путь:** Начинается с `d.` или `c.` (ссылается на корневые или дополнительные данные).
- **Относительный JSON-путь:** Начинается с одной точки (`.`), указывая, что свойство ищется в текущем родительском объекте.

Например:
```
{d.subObject.qtyB:add(d.subObject.qtyC)}
```
Это также можно записать как относительный путь:
```
{d.subObject.qtyB:add(.qtyC)}
```
Если вам нужно получить доступ к данным более высокого уровня (родительского или выше), вы можете использовать несколько точек:
```
{d.subObject.qtyB:add(..qtyA):add(.qtyC)}
```

#### 2. Пример
Данные:
```json
{
  "id": 10,
  "qtyA": 20,
  "subObject": {
    "qtyB": 5,
    "qtyC": 3
  },
  "subArray": [{
    "id": 1000,
    "qtyE": 3
  }]
}
```
Использование в шаблоне:
```
{d.subObject.qtyB:add(d.subObject.qtyC)}      // Результат: 8 (5 + 3)
{d.subObject.qtyB:add(.qtyC)}                   // Результат: 8
{d.subObject.qtyB:add(..qtyA):add(.qtyC)}        // Результат: 28 (5 + 20 + 3)
{d.subArray[0].qtyE:add(..subObject.qtyC)}       // Результат: 6 (3 + 3)
```

#### 3. Результат
В результате выполнения примеров будут получены значения 8, 8, 28 и 6 соответственно.

> **Обратите внимание:** Использование пользовательских итераторов или фильтров массива в качестве динамических параметров не допускается, например:
> ```
> {d.subObject.qtyB:add(..subArray[i].qtyE)}
> {d.subObject.qtyB:add(d.subArray[i].qtyE)}
> ```