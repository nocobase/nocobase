:::tip Уведомление о переводе ИИ
Эта документация была автоматически переведена ИИ.
:::

# Поле

## Обзор

Это абстрактный класс для управления полями **коллекции**. Он также является базовым классом для всех типов полей. Любой другой тип поля реализуется путём наследования от этого класса.

Информацию о том, как настроить собственные поля, вы найдёте в разделе [Расширение типов полей].

## Конструктор

Обычно разработчики не вызывают его напрямую. Он используется как прокси-точка входа через метод `db.collection({ fields: [] })`.

При расширении полей вы реализуете их, наследуя от абстрактного класса `Field`, а затем регистрируя в экземпляре Database.

**Сигнатура**

- `constructor(options: FieldOptions, context: FieldContext)`

**Параметры**

| Параметр             | Тип            | По умолчанию | Описание                                                              |
| :------------------- | :------------- | :----------- | :-------------------------------------------------------------------- |
| `options`            | `FieldOptions` | -            | Объект конфигурации поля                                             |
| `options.name`       | `string`       | -            | Имя поля                                                              |
| `options.type`       | `string`       | -            | Тип поля, соответствующий имени типа поля, зарегистрированного в `db` |
| `context`            | `FieldContext` | -            | Объект контекста поля                                                 |
| `context.database`   | `Database`     | -            | Экземпляр базы данных                                                 |
| `context.collection` | `Collection`   | -            | Экземпляр **коллекции**                                               |

## Члены экземпляра

### `name`

Имя поля.

### `type`

Тип поля.

### `dataType`

Тип хранения поля в базе данных.

### `options`

Параметры конфигурации инициализации поля.

### `context`

Объект контекста поля.

## Методы конфигурации

### `on()`

Это сокращённый способ определения обработчиков для событий **коллекции**. Эквивалентно вызову `db.on(this.collection.name + '.' + eventName, listener)`.

При наследовании обычно нет необходимости переопределять этот метод.

**Сигнатура**

- `on(eventName: string, listener: (...args: any[]) => void)`

**Параметры**

| Параметр    | Тип                        | По умолчанию | Описание          |
| :---------- | :------------------------- | :----------- | :---------------- |
| `eventName` | `string`                   | -            | Имя события       |
| `listener`  | `(...args: any[]) => void` | -            | Слушатель события |

### `off()`

Это сокращённый способ удаления обработчиков для событий **коллекции**. Эквивалентно вызову `db.off(this.collection.name + '.' + eventName, listener)`.

При наследовании обычно нет необходимости переопределять этот метод.

**Сигнатура**

- `off(eventName: string, listener: (...args: any[]) => void)`

**Параметры**

| Параметр    | Тип                        | По умолчанию | Описание          |
| :---------- | :------------------------- | :----------- | :---------------- |
| `eventName` | `string`                   | -            | Имя события       |
| `listener`  | `(...args: any[]) => void` | -            | Слушатель события |

### `bind()`

Содержимое, которое выполняется при добавлении поля в **коллекцию**. Обычно используется для добавления слушателей событий **коллекции** и другой обработки.

При наследовании необходимо сначала вызвать соответствующий метод `super.bind()`.

**Сигнатура**

- `bind()`

### `unbind()`

Содержимое, которое выполняется при удалении поля из **коллекции**. Обычно используется для удаления слушателей событий **коллекции** и другой обработки.

При наследовании необходимо сначала вызвать соответствующий метод `super.unbind()`.

**Сигнатура**

- `unbind()`

### `get()`

Получает значение параметра конфигурации поля.

**Сигнатура**

- `get(key: string): any`

**Параметры**

| Параметр | Тип      | По умолчанию | Описание                  |
| :------- | :------- | :----------- | :------------------------ |
| `key`    | `string` | -            | Имя параметра конфигурации |

**Пример**

```ts
const field = db.collection('users').getField('name');

// Получает значение параметра конфигурации имени поля, возвращает 'name'
console.log(field.get('name'));
```

### `merge()`

Объединяет значения параметров конфигурации поля.

**Сигнатура**

- `merge(options: { [key: string]: any }): void`

**Параметры**

| Параметр  | Тип                      | По умолчанию | Описание                               |
| :-------- | :----------------------- | :----------- | :------------------------------------- |
| `options` | `{ [key: string]: any }` | -            | Объект параметров конфигурации для объединения |

**Пример**

```ts
const field = db.collection('users').getField('name');

field.merge({
  // Добавляем конфигурацию индекса
  index: true,
});
```

### `remove()`

Удаляет поле из **коллекции** (только из памяти).

**Пример**

```ts
const books = db.getCollections('books');

books.getField('isbn').remove();

// фактически удаляем из базы данных
await books.sync();
```

## Методы базы данных

### `removeFromDb()`

Удаляет поле из базы данных.

**Сигнатура**

- `removeFromDb(options?: Transactionable): Promise<void>`

**Параметры**

| Параметр               | Тип           | По умолчанию | Описание           |
| :--------------------- | :------------ | :----------- | :----------------- |
| `options.transaction?` | `Transaction` | -            | Экземпляр транзакции |

### `existsInDb()`

Определяет, существует ли поле в базе данных.

**Сигнатура**

- `existsInDb(options?: Transactionable): Promise<boolean>`

**Параметры**

| Параметр               | Тип           | По умолчанию | Описание           |
| :--------------------- | :------------ | :----------- | :----------------- |
| `options.transaction?` | `Transaction` | -            | Экземпляр транзакции |

## Список встроенных типов полей

NocoBase включает в себя несколько часто используемых типов полей. Вы можете напрямую указывать тип поля при определении полей **коллекции**, используя соответствующее имя `type`. Различные типы полей имеют разные параметры конфигурации; подробности смотрите в списке ниже.

Все параметры конфигурации для типов полей, за исключением тех, что описаны ниже, будут переданы в Sequelize. Таким образом, здесь можно использовать все параметры конфигурации полей, поддерживаемые Sequelize (например, `allowNull`, `defaultValue` и т.д.).

Кроме того, серверные типы полей в основном решают задачи хранения данных в базе данных и некоторые алгоритмические проблемы, и, как правило, не связаны с типами отображения полей и используемыми компонентами на стороне фронтенда. Информацию о типах полей для фронтенда можно найти в соответствующем разделе руководства.

### `'boolean'`

Логический тип данных.

**Пример**

```js
db.collection({
  name: 'books',
  fields: [
    {
      type: 'boolean',
      name: 'published',
    },
  ],
});
```

### `'integer'`

Целочисленный тип (32-битный).

**Пример**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'integer',
      name: 'pages',
    },
  ],
});
```

### `'bigInt'`

Длинный целочисленный тип (64-битный).

**Пример**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'bigInt',
      name: 'words',
    },
  ],
});
```

### `'double'`

Тип с плавающей запятой двойной точности (64-битный).

**Пример**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'double',
      name: 'price',
    },
  ],
});
```

### `'real'`

Тип вещественного числа (только для PostgreSQL).

### `'decimal'`

Десятичный тип числа.

### `'string'`

Строковый тип. Эквивалентен типу `VARCHAR` в большинстве баз данных.

**Пример**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'string',
      name: 'title',
    },
  ],
});
```

### `'text'`

Текстовый тип. Эквивалентен типу `TEXT` в большинстве баз данных.

**Пример**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'text',
      name: 'content',
    },
  ],
});
```

### `'password'`

Тип пароля (расширение NocoBase). Шифрует пароли с использованием метода `scrypt` из нативного пакета `crypto` Node.js.

**Пример**

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'password',
      name: 'password',
      length: 64, // Длина, по умолчанию 64
      randomBytesSize: 8, // Длина случайных байтов, по умолчанию 8
    },
  ],
});
```

**Параметры**

| Параметр          | Тип      | По умолчанию | Описание                |
| :---------------- | :------- | :----------- | :---------------------- |
| `length`          | `number` | 64           | Длина символов          |
| `randomBytesSize` | `number` | 8            | Размер случайных байтов |

### `'date'`

Тип даты.

### `'time'`

Тип времени.

### `'array'`

Тип массива (только для PostgreSQL).

### `'json'`

Тип JSON.

### `'jsonb'`

Тип JSONB (только для PostgreSQL, в других случаях будет совместим с типом `'json'`).

### `'uuid'`

Тип UUID.

### `'uid'`

Тип UID (расширение NocoBase). Тип короткого случайного строкового идентификатора.

### `'formula'`

Тип формулы (расширение NocoBase). Позволяет настраивать вычисления математических формул на основе [mathjs](https://www.npmjs.com/package/mathjs). В формуле можно ссылаться на значения других столбцов той же записи для участия в расчётах.

**Пример**

```ts
db.collection({
  name: 'orders',
  fields: [
    {
      type: 'double',
      name: 'price',
    },
    {
      type: 'integer',
      name: 'quantity',
    },
    {
      type: 'formula',
      name: 'total',
      expression: 'price * quantity',
    },
  ],
});
```

### `'radio'`

Тип "радиокнопка" (расширение NocoBase). Вся **коллекция** может содержать не более одной записи, у которой значение этого поля равно `true`; у всех остальных записей оно будет `false` или `null`.

**Пример**

Вся система содержит только одного пользователя, помеченного как `root`. Если значение `root` для любого другого пользователя будет изменено на `true`, все остальные записи, у которых `root` было `true`, будут изменены на `false`:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'radio',
      name: 'root',
    },
  ],
});
```

### `'sort'`

Тип сортировки (расширение NocoBase). Сортирует на основе целочисленных значений, автоматически генерирует новый порядковый номер для новых записей и переупорядочивает номера при перемещении данных.

Если для **коллекции** определён параметр `sortable`, соответствующее поле также будет сгенерировано автоматически.

**Пример**

Статьи могут быть отсортированы по пользователю, которому они принадлежат:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsTo',
      name: 'user',
    },
    {
      type: 'sort',
      name: 'priority',
      scopeKey: 'userId', // Сортировка данных, сгруппированных по одинаковому значению userId
    },
  ],
});
```

### `'virtual'`

Виртуальный тип. Фактически не хранит данные, используется только для определения специальных геттеров/сеттеров.

### `'belongsTo'`

Тип связи "многие к одному". Внешний ключ хранится в собственной таблице, в отличие от `hasOne`/`hasMany`.

**Пример**

Любая статья принадлежит определённому автору:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsTo',
      name: 'author',
      target: 'users', // Если не указано, по умолчанию используется имя коллекции в форме множественного числа от name
      foreignKey: 'authorId', // Если не указано, по умолчанию используется формат <name> + Id
      sourceKey: 'id', // Если не указано, по умолчанию используется id целевой коллекции
    },
  ],
});
```

### `'hasOne'`

Тип связи "один к одному". Внешний ключ хранится в связанной **коллекции**, в отличие от `belongsTo`.

**Пример**

У каждого пользователя есть профиль:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'hasOne',
      name: 'profile',
      target: 'profiles', // Можно опустить
    },
  ],
});
```

### `'hasMany'`

Тип связи "один ко многим". Внешний ключ хранится в связанной **коллекции**, в отличие от `belongsTo`.

**Пример**

Любой пользователь может иметь несколько статей:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'hasMany',
      name: 'posts',
      foreignKey: 'authorId',
      sourceKey: 'id',
    },
  ],
});
```

### `'belongsToMany'`

Тип связи "многие ко многим". Использует промежуточную **коллекцию** для хранения внешних ключей обеих сторон. Если существующая **коллекция** не указана как промежуточная, она будет создана автоматически.

**Пример**

Любая статья может иметь несколько тегов, и любой тег может быть добавлен к нескольким статьям:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsToMany',
      name: 'tags',
      target: 'tags', // Можно опустить, если имя совпадает
      through: 'postsTags', // Промежуточная коллекция будет сгенерирована автоматически, если не настроена
      foreignKey: 'postId', // Внешний ключ исходной коллекции в промежуточной коллекции
      sourceKey: 'id', // Первичный ключ исходной коллекции
      otherKey: 'tagId', // Внешний ключ целевой коллекции в промежуточной коллекции
    },
  ],
});

db.collection({
  name: 'tags',
  fields: [
    {
      type: 'belongsToMany',
      name: 'posts',
      through: 'postsTags', // Одна и та же группа связей указывает на одну и ту же промежуточную коллекцию
    },
  ],
});
```