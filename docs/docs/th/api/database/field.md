:::tip
เอกสารนี้แปลโดย AI หากมีข้อมูลที่ไม่ถูกต้อง โปรดดู[เวอร์ชันภาษาอังกฤษ](/en)
:::


# ฟิลด์

## ภาพรวม

นี่คือคลาสสำหรับจัดการฟิลด์ของคอลเลกชัน (คลาส Abstract) และยังเป็นคลาสพื้นฐานสำหรับฟิลด์ทุกประเภท โดยฟิลด์ประเภทอื่น ๆ ทั้งหมดจะถูกสร้างขึ้นโดยการสืบทอด (inherit) จากคลาสนี้ครับ/ค่ะ

หากต้องการเรียนรู้วิธีการสร้างฟิลด์แบบกำหนดเอง สามารถดูได้ที่ [การขยายประเภทฟิลด์]

## Constructor

โดยปกติแล้ว นักพัฒนาจะไม่เรียกใช้ Constructor นี้โดยตรง แต่จะถูกเรียกผ่านเมธอด `db.collection({ fields: [] })` ซึ่งทำหน้าที่เป็นทางเข้าแบบพร็อกซีครับ/ค่ะ

เมื่อต้องการขยายฟิลด์ จะทำได้โดยการสืบทอดจากคลาส Abstract `Field` แล้วจึงลงทะเบียน (register) เข้ากับอินสแตนซ์ของ Database ครับ/ค่ะ

**รูปแบบการใช้งาน (Signature)**

- `constructor(options: FieldOptions, context: FieldContext)`

**พารามิเตอร์**

| ชื่อพารามิเตอร์      | ประเภท           | ค่าเริ่มต้น | คำอธิบาย                                     |
| -------------------- | -------------- | ------ | ---------------------------------------- |
| `options`            | `FieldOptions` | -      | ออบเจกต์การตั้งค่าฟิลด์                             |
| `options.name`       | `string`       | -      | ชื่อฟิลด์                                 |
| `options.type`       | `string`       | -      | ประเภทฟิลด์ ซึ่งตรงกับชื่อประเภทฟิลด์ที่ลงทะเบียนไว้ใน `db` |
| `context`            | `FieldContext` | -      | ออบเจกต์บริบทของฟิลด์                           |
| `context.database`   | `Database`     | -      | อินสแตนซ์ของ Database                               |
| `context.collection` | `Collection`   | -      | อินสแตนซ์ของคอลเลกชัน                               |

## สมาชิกอินสแตนซ์

### `name`

ชื่อฟิลด์

### `type`

ประเภทฟิลด์

### `dataType`

ประเภทการจัดเก็บข้อมูลของฟิลด์ในฐานข้อมูล

### `options`

พารามิเตอร์การตั้งค่าเริ่มต้นของฟิลด์

### `context`

ออบเจกต์บริบทของฟิลด์

## เมธอดการตั้งค่า

### `on()`

เมธอดสำหรับกำหนดเหตุการณ์ของคอลเลกชันแบบรวดเร็ว เทียบเท่ากับการใช้ `db.on(this.collection.name + '.' + eventName, listener)` ครับ/ค่ะ

โดยปกติแล้ว ไม่จำเป็นต้องเขียนทับ (override) เมธอดนี้เมื่อทำการสืบทอดครับ/ค่ะ

**รูปแบบการใช้งาน (Signature)**

- `on(eventName: string, listener: (...args: any[]) => void)`

**พารามิเตอร์**

| ชื่อพารามิเตอร์ | ประเภท                       | ค่าเริ่มต้น | คำอธิบาย       |
| ----------- | -------------------------- | ------ | ---------- |
| `eventName` | `string`                   | -      | ชื่อเหตุการณ์   |
| `listener`  | `(...args: any[]) => void` | -      | ตัวฟังเหตุการณ์ (Event Listener) |

### `off()`

เมธอดสำหรับลบเหตุการณ์ของคอลเลกชันแบบรวดเร็ว เทียบเท่ากับการใช้ `db.off(this.collection.name + '.' + eventName, listener)` ครับ/ค่ะ

โดยปกติแล้ว ไม่จำเป็นต้องเขียนทับ (override) เมธอดนี้เมื่อทำการสืบทอดครับ/ค่ะ

**รูปแบบการใช้งาน (Signature)**

- `off(eventName: string, listener: (...args: any[]) => void)`

**พารามิเตอร์**

| ชื่อพารามิเตอร์ | ประเภท                       | ค่าเริ่มต้น | คำอธิบาย       |
| ----------- | -------------------------- | ------ | ---------- |
| `eventName` | `string`                   | -      | ชื่อเหตุการณ์   |
| `listener`  | `(...args: any[]) => void` | -      | ตัวฟังเหตุการณ์ (Event Listener) |

### `bind()`

เนื้อหาที่จะถูกเรียกใช้เมื่อฟิลด์ถูกเพิ่มลงในคอลเลกชัน โดยทั่วไปจะใช้เพื่อเพิ่มตัวฟังเหตุการณ์ของคอลเลกชันและการประมวลผลอื่น ๆ ครับ/ค่ะ

เมื่อทำการสืบทอด จะต้องเรียกใช้เมธอด `super.bind()` ที่เกี่ยวข้องก่อนครับ/ค่ะ

**รูปแบบการใช้งาน (Signature)**

- `bind()`

### `unbind()`

เนื้อหาที่จะถูกเรียกใช้เมื่อฟิลด์ถูกลบออกจากคอลเลกชัน โดยทั่วไปจะใช้เพื่อลบตัวฟังเหตุการณ์ของคอลเลกชันและการประมวลผลอื่น ๆ ครับ/ค่ะ

เมื่อทำการสืบทอด จะต้องเรียกใช้เมธอด `super.unbind()` ที่เกี่ยวข้องก่อนครับ/ค่ะ

**รูปแบบการใช้งาน (Signature)**

- `unbind()`

### `get()`

ใช้สำหรับดึงค่าของรายการตั้งค่าฟิลด์

**รูปแบบการใช้งาน (Signature)**

- `get(key: string): any`

**พารามิเตอร์**

| ชื่อพารามิเตอร์ | ประเภท     | ค่าเริ่มต้น | คำอธิบาย       |
| ------ | -------- | ------ | ---------- |
| `key`  | `string` | -      | ชื่อรายการตั้งค่า |

**ตัวอย่าง**

```ts
const field = db.collection('users').getField('name');

// ดึงค่าของรายการตั้งค่าชื่อฟิลด์ ซึ่งจะคืนค่า 'name'
console.log(field.get('name'));
```

### `merge()`

ใช้สำหรับรวมค่าของรายการตั้งค่าฟิลด์

**รูปแบบการใช้งาน (Signature)**

- `merge(options: { [key: string]: any }): void`

**พารามิเตอร์**

| ชื่อพารามิเตอร์ | ประเภท                     | ค่าเริ่มต้น | คำอธิบาย               |
| --------- | ------------------------ | ------ | ------------------ |
| `options` | `{ [key: string]: any }` | -      | ออบเจกต์รายการตั้งค่าที่ต้องการรวม |

**ตัวอย่าง**

```ts
const field = db.collection('users').getField('name');

field.merge({
  // เพิ่มการตั้งค่าดัชนี
  index: true,
});
```

### `remove()`

ใช้สำหรับลบฟิลด์ออกจากคอลเลกชัน (เป็นการลบจากหน่วยความจำเท่านั้น)

**ตัวอย่าง**

```ts
const books = db.getCollections('books');

books.getField('isbn').remove();

// ลบออกจากฐานข้อมูลจริง ๆ
await books.sync();
```

## เมธอดของฐานข้อมูล

### `removeFromDb()`

ใช้สำหรับลบฟิลด์ออกจากฐานข้อมูล

**รูปแบบการใช้งาน (Signature)**

- `removeFromDb(options?: Transactionable): Promise<void>`

**พารามิเตอร์**

| ชื่อพารามิเตอร์        | ประเภท          | ค่าเริ่มต้น | คำอธิบาย     |
| ---------------------- | ------------- | ------ | -------- |
| `options.transaction?` | `Transaction` | -      | อินสแตนซ์ของ Transaction |

### `existsInDb()`

ใช้สำหรับตรวจสอบว่าฟิลด์มีอยู่ในฐานข้อมูลหรือไม่

**รูปแบบการใช้งาน (Signature)**

- `existsInDb(options?: Transactionable): Promise<boolean>`

**พารามิเตอร์**

| ชื่อพารามิเตอร์        | ประเภท          | ค่าเริ่มต้น | คำอธิบาย     |
| ---------------------- | ------------- | ------ | -------- |
| `options.transaction?` | `Transaction` | -      | อินสแตนซ์ของ Transaction |

## รายการประเภทฟิลด์ในตัว

NocoBase มีประเภทฟิลด์ที่ใช้งานบ่อย ๆ ในตัว ซึ่งคุณสามารถใช้ชื่อ `type` ที่เกี่ยวข้องเพื่อระบุประเภทได้โดยตรงเมื่อกำหนดฟิลด์สำหรับคอลเลกชันครับ/ค่ะ ฟิลด์แต่ละประเภทมีการตั้งค่าพารามิเตอร์ที่แตกต่างกัน สามารถดูรายละเอียดได้จากรายการด้านล่างนี้ครับ/ค่ะ

รายการตั้งค่าทั้งหมดสำหรับฟิลด์ทุกประเภท นอกเหนือจากที่อธิบายเพิ่มเติมด้านล่างนี้ จะถูกส่งผ่านไปยัง Sequelize โดยตรง ดังนั้นรายการตั้งค่าฟิลด์ทั้งหมดที่ Sequelize รองรับสามารถนำมาใช้ได้ที่นี่ครับ/ค่ะ (เช่น `allowNull`, `defaultValue` เป็นต้น)

นอกจากนี้ ประเภทฟิลด์ฝั่งเซิร์ฟเวอร์ส่วนใหญ่จะจัดการกับการจัดเก็บข้อมูลในฐานข้อมูลและปัญหาเกี่ยวกับอัลกอริทึมบางส่วน ซึ่งโดยพื้นฐานแล้วไม่เกี่ยวข้องกับประเภทการแสดงผลฟิลด์และคอมโพเนนต์ที่ใช้ในส่วนหน้า (frontend) ครับ/ค่ะ สำหรับประเภทฟิลด์ฝั่งหน้าบ้าน (frontend) สามารถดูคำอธิบายที่เกี่ยวข้องในบทเรียนได้ครับ/ค่ะ

### `'boolean'`

ประเภทค่าตรรกะ (Boolean)

**ตัวอย่าง**

```js
db.collection({
  name: 'books',
  fields: [
    {
      type: 'boolean',
      name: 'published',
    },
  ],
});
```

### `'integer'`

ประเภทจำนวนเต็ม (32 บิต)

**ตัวอย่าง**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'integer',
      name: 'pages',
    },
  ],
});
```

### `'bigInt'`

ประเภทจำนวนเต็มขนาดใหญ่ (64 บิต)

**ตัวอย่าง**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'bigInt',
      name: 'words',
    },
  ],
});
```

### `'double'`

ประเภททศนิยมความแม่นยำสองเท่า (64 บิต)

**ตัวอย่าง**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'double',
      name: 'price',
    },
  ],
});
```

### `'real'`

ประเภทจำนวนจริง (ใช้ได้กับ PG เท่านั้น)

### `'decimal'`

ประเภททศนิยม

### `'string'`

ประเภทสตริง เทียบเท่ากับประเภท `VARCHAR` ในฐานข้อมูลส่วนใหญ่ครับ/ค่ะ

**ตัวอย่าง**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'string',
      name: 'title',
    },
  ],
});
```

### `'text'`

ประเภทข้อความ เทียบเท่ากับประเภท `TEXT` ในฐานข้อมูลส่วนใหญ่ครับ/ค่ะ

**ตัวอย่าง**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'text',
      name: 'content',
    },
  ],
});
```

### `'password'`

ประเภทรหัสผ่าน (ส่วนขยายของ NocoBase) ใช้เมธอด `scrypt` จากแพ็กเกจ `crypto` ดั้งเดิมของ Node.js ในการเข้ารหัสรหัสผ่านครับ/ค่ะ

**ตัวอย่าง**

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'password',
      name: 'password',
      length: 64, // ความยาว, ค่าเริ่มต้นคือ 64
      randomBytesSize: 8, // ความยาวไบต์สุ่ม, ค่าเริ่มต้นคือ 8
    },
  ],
});
```

**พารามิเตอร์**

| ชื่อพารามิเตอร์    | ประเภท     | ค่าเริ่มต้น | คำอธิบาย         |
| ----------------- | -------- | ------ | ------------ |
| `length`          | `number` | 64     | ความยาวอักขระ     |
| `randomBytesSize` | `number` | 8      | ขนาดไบต์สุ่ม |

### `'date'`

ประเภทวันที่

### `'time'`

ประเภทเวลา

### `'array'`

ประเภทอาร์เรย์ (ใช้ได้กับ PG เท่านั้น)

### `'json'`

ประเภท JSON

### `'jsonb'`

ประเภท JSONB (ใช้ได้กับ PG เท่านั้น ส่วนประเภทอื่น ๆ จะถูกแปลงให้เข้ากันได้กับประเภท `'json'` ครับ/ค่ะ)

### `'uuid'`

ประเภท UUID

### `'uid'`

ประเภท UID (ส่วนขยายของ NocoBase) ประเภทตัวระบุสตริงสุ่มแบบสั้น

### `'formula'`

ประเภทสูตร (ส่วนขยายของ NocoBase) สามารถกำหนดค่าการคำนวณสูตรทางคณิตศาสตร์โดยอิงตาม [mathjs](https://www.npmjs.com/package/mathjs) ได้ โดยในสูตรสามารถอ้างอิงค่าจากคอลัมน์อื่น ๆ ในเรคคอร์ดเดียวกันเพื่อนำมาคำนวณได้ครับ/ค่ะ

**ตัวอย่าง**

```ts
db.collection({
  name: 'orders',
  fields: [
    {
      type: 'double',
      name: 'price',
    },
    {
      type: 'integer',
      name: 'quantity',
    },
    {
      type: 'formula',
      name: 'total',
      expression: 'price * quantity',
    },
  ],
});
```

### `'radio'`

ประเภท Radio (ส่วนขยายของ NocoBase) ในคอลเลกชันทั้งหมด จะมีข้อมูลเพียงหนึ่งแถวเท่านั้นที่ฟิลด์นี้มีค่าเป็น `true` ส่วนที่เหลือจะเป็น `false` หรือ `null` ครับ/ค่ะ

**ตัวอย่าง**

ในระบบทั้งหมดจะมีผู้ใช้เพียงคนเดียวที่ถูกทำเครื่องหมายว่าเป็น `root` หากค่า `root` ของผู้ใช้อื่นถูกเปลี่ยนเป็น `true` เรคคอร์ดทั้งหมดที่มี `root` เป็น `true` อยู่ก่อนหน้าจะถูกเปลี่ยนเป็น `false` ครับ/ค่ะ

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'radio',
      name: 'root',
    },
  ],
});
```

### `'sort'`

ประเภทการเรียงลำดับ (ส่วนขยายของ NocoBase) ใช้สำหรับการเรียงลำดับตามตัวเลขจำนวนเต็ม โดยจะสร้างลำดับใหม่โดยอัตโนมัติสำหรับเรคคอร์ดใหม่ และจะจัดเรียงลำดับใหม่เมื่อมีการย้ายข้อมูลครับ/ค่ะ

หากคอลเลกชันมีการกำหนดตัวเลือก `sortable` ไว้ ฟิลด์ที่เกี่ยวข้องก็จะถูกสร้างขึ้นโดยอัตโนมัติเช่นกันครับ/ค่ะ

**ตัวอย่าง**

บทความสามารถเรียงลำดับตามผู้ใช้ที่เป็นเจ้าของได้ครับ/ค่ะ

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsTo',
      name: 'user',
    },
    {
      type: 'sort',
      name: 'priority',
      scopeKey: 'userId', // เรียงลำดับข้อมูลที่จัดกลุ่มตามค่า `userId` ที่เหมือนกัน
    },
  ],
});
```

### `'virtual'`

ประเภทเสมือน (Virtual) ไม่ได้จัดเก็บข้อมูลจริง แต่ใช้สำหรับการกำหนด getter/setter แบบพิเศษเท่านั้นครับ/ค่ะ

### `'belongsTo'`

ประเภทความสัมพันธ์แบบ Many-to-One คีย์นอก (Foreign Key) จะถูกเก็บไว้ในตารางของตัวเอง ซึ่งตรงข้ามกับ `hasOne`/`hasMany` ครับ/ค่ะ

**ตัวอย่าง**

บทความใด ๆ เป็นของนักเขียนคนใดคนหนึ่งครับ/ค่ะ

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsTo',
      name: 'author',
      target: 'users', // หากไม่ได้กำหนด จะใช้ชื่อคอลเลกชันที่เป็นรูปพหูพจน์ของ `name` เป็นค่าเริ่มต้น
      foreignKey: 'authorId', // หากไม่ได้กำหนด จะใช้รูปแบบ `<name> + Id` เป็นค่าเริ่มต้น
      sourceKey: 'id', // หากไม่ได้กำหนด จะใช้ `id` ของคอลเลกชันเป้าหมายเป็นค่าเริ่มต้น
    },
  ],
});
```

### `'hasOne'`

ประเภทความสัมพันธ์แบบ One-to-One คีย์นอก (Foreign Key) จะถูกเก็บไว้ในตารางที่เกี่ยวข้อง ซึ่งตรงข้ามกับ `belongsTo` ครับ/ค่ะ

**ตัวอย่าง**

ผู้ใช้ทุกคนมีโปรไฟล์ส่วนตัวหนึ่งชุดครับ/ค่ะ

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'hasOne',
      name: 'profile',
      target: 'profiles', // สามารถละไว้ได้
    },
  ],
});
```

### `'hasMany'`

ประเภทความสัมพันธ์แบบ One-to-Many คีย์นอก (Foreign Key) จะถูกเก็บไว้ในตารางที่เกี่ยวข้อง ซึ่งตรงข้ามกับ `belongsTo` ครับ/ค่ะ

**ตัวอย่าง**

ผู้ใช้แต่ละคนสามารถมีบทความได้หลายบทความครับ/ค่ะ

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'hasMany',
      name: 'posts',
      foreignKey: 'authorId',
      sourceKey: 'id',
    },
  ],
});
```

### `'belongsToMany'`

ประเภทความสัมพันธ์แบบ Many-to-Many ใช้ตารางกลาง (through collection) ในการจัดเก็บคีย์นอกของทั้งสองฝ่าย หากไม่ได้ระบุตารางที่มีอยู่ให้เป็นตารางกลาง ระบบจะสร้างตารางกลางขึ้นมาโดยอัตโนมัติครับ/ค่ะ

**ตัวอย่าง**

บทความใด ๆ สามารถเพิ่มแท็กได้หลายแท็ก และแท็กใด ๆ ก็สามารถถูกเพิ่มในบทความได้หลายบทความเช่นกันครับ/ค่ะ

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsToMany',
      name: 'tags',
      target: 'tags', // สามารถละไว้ได้หากชื่อเหมือนกัน
      through: 'postsTags', // หากไม่ได้กำหนดตารางกลาง ระบบจะสร้างขึ้นโดยอัตโนมัติ
      foreignKey: 'postId', // คีย์นอกของคอลเลกชันต้นทางในตารางกลาง
      sourceKey: 'id', // คีย์หลักของคอลเลกชันต้นทาง
      otherKey: 'tagId', // คีย์นอกของคอลเลกชันปลายทางในตารางกลาง
    },
  ],
});

db.collection({
  name: 'tags',
  fields: [
    {
      type: 'belongsToMany',
      name: 'posts',
      through: 'postsTags', // ความสัมพันธ์ชุดเดียวกันจะชี้ไปยังตารางกลางเดียวกัน
    },
  ],
});
```