:::tip Повідомлення про переклад ШІ
Ця документація була автоматично перекладена штучним інтелектом.
:::


## Форматувальники

Форматувальники використовуються для перетворення сирих даних у текст, який легко читати. Вони застосовуються до даних за допомогою двокрапки (`:`) і можуть бути об'єднані в ланцюжок, так що вихід одного форматувальника стає входом для наступного. Деякі форматувальники підтримують константні або динамічні параметри.


### Огляд

#### 1. Пояснення синтаксису
Базовий виклик форматувальника виглядає так:
```
{d.property:formatter1:formatter2(...)}
```  
Наприклад, щоб перетворити рядок `"JOHN"` на `"John"`, спочатку використовується форматувальник `lowerCase` для переведення всіх літер у нижній регістр, а потім `ucFirst` для написання першої літери з великої.

#### 2. Приклад
Дані:
```json
{
  "name": "JOHN",
  "birthday": "2000-01-31"
}
```
Шаблон:
```
My name is {d.name:lowerCase:ucFirst}. I was born on {d.birthday:formatD(LL)}.
```

#### 3. Результат
Після рендерингу вивід буде таким:
```
My name is John. I was born on January 31, 2000.
```


### Константні параметри

#### 1. Пояснення синтаксису
Багато форматувальників підтримують один або кілька константних параметрів, які розділяються комами та поміщаються в круглі дужки для зміни виводу. Наприклад, `:prepend(myPrefix)` додасть "myPrefix" перед текстом.  
**Зверніть увагу:** Якщо параметр містить коми або пробіли, його необхідно взяти в одинарні лапки, наприклад: `prepend('my prefix')`.

#### 2. Приклад
Приклад шаблону (детальніше дивіться у використанні конкретних форматувальників).

#### 3. Результат
Вивід матиме вказаний префікс, доданий перед текстом.


### Динамічні параметри

#### 1. Пояснення синтаксису
Форматувальники також підтримують динамічні параметри. Ці параметри починаються з крапки (`.`) і не беруться в лапки.  
Існує два способи вказати динамічні параметри:
- **Абсолютний JSON-шлях:** Починається з `d.` або `c.` (посилається на кореневі або додаткові дані).
- **Відносний JSON-шлях:** Починається з однієї крапки (`.`), вказуючи, що властивість шукається в поточному батьківському об'єкті.

Наприклад:
```
{d.subObject.qtyB:add(d.subObject.qtyC)}
```
Це також можна записати як відносний шлях:
```
{d.subObject.qtyB:add(.qtyC)}
```
Якщо вам потрібно отримати доступ до даних вищого рівня (батьківського або вище), ви можете використовувати кілька крапок:
```
{d.subObject.qtyB:add(..qtyA):add(.qtyC)}
```

#### 2. Приклад
Дані:
```json
{
  "id": 10,
  "qtyA": 20,
  "subObject": {
    "qtyB": 5,
    "qtyC": 3
  },
  "subArray": [{
    "id": 1000,
    "qtyE": 3
  }]
}
```
Використання в шаблоні:
```
{d.subObject.qtyB:add(d.subObject.qtyC)}      // Результат: 8 (5 + 3)
{d.subObject.qtyB:add(.qtyC)}                   // Результат: 8
{d.subObject.qtyB:add(..qtyA):add(.qtyC)}        // Результат: 28 (5 + 20 + 3)
{d.subArray[0].qtyE:add(..subObject.qtyC)}       // Результат: 6 (3 + 3)
```

#### 3. Результат
Приклади дають 8, 8, 28 та 6 відповідно.

> **Примітка:** Використання користувацьких ітераторів або фільтрів масивів як динамічних параметрів не допускається, наприклад:
> ```
> {d.subObject.qtyB:add(..subArray[i].qtyE)}
> {d.subObject.qtyB:add(d.subArray[i].qtyE)}
> ```