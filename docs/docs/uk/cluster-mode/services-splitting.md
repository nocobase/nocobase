:::tip Повідомлення про переклад ШІ
Ця документація була автоматично перекладена штучним інтелектом.
:::


# Розділення сервісів <Badge>v1.9.0+</Badge>

## Вступ

Зазвичай, усі сервіси застосунку NocoBase працюють в одному екземплярі Node.js. Коли функціональність застосунку стає складнішою в міру розвитку бізнесу, деякі ресурсомісткі сервіси можуть впливати на загальну продуктивність.

Щоб підвищити продуктивність застосунку, NocoBase підтримує розділення сервісів застосунку для роботи на різних вузлах у кластерному режимі. Це допомагає уникнути ситуацій, коли проблеми з продуктивністю одного сервісу впливають на весь застосунок, заважаючи йому нормально відповідати на запити користувачів.

З іншого боку, це також дозволяє цілеспрямовано масштабувати певні сервіси по горизонталі, підвищуючи ефективність використання ресурсів кластера.

При розгортанні NocoBase у кластері різні сервіси можна розділити та розгорнути для роботи на різних вузлах. Наведена нижче діаграма ілюструє структуру розділення:

![20250803214857](https://static-docs.nocobase.com/20250803214857.png)

## Які сервіси можна розділити

### Асинхронний робочий процес

**Ключ сервісу**: `workflow:process`

Робочі процеси в асинхронному режимі після запуску стають у чергу на виконання. Такі робочі процеси можна розглядати як фонові завдання, і користувачам зазвичай не потрібно чекати повернення результатів. Особливо для складних і ресурсомістких процесів із великою кількістю запусків рекомендується розділяти їх для роботи на незалежних вузлах.

### Інші асинхронні завдання користувацького рівня

**Ключ сервісу**: `async-task:process`

Сюди входять завдання, створені діями користувачів, такі як асинхронний імпорт та експорт. У випадках великих обсягів даних або високої конкуренції рекомендується розділяти їх для роботи на незалежних вузлах.

## Як розділити сервіси

Розділення різних сервісів на різні вузли реалізується шляхом конфігурації змінної середовища `WORKER_MODE`. Цю змінну середовища можна налаштувати відповідно до таких правил:

- `WORKER_MODE=<порожньо>`: Якщо не налаштовано або встановлено порожнім, режим роботи ідентичний поточному одноекземплярному режиму: приймає всі запити та обробляє всі завдання. Це сумісно із застосунками, які раніше не були налаштовані.
- `WORKER_MODE=!`: Режим роботи передбачає лише обробку запитів, без обробки будь-яких завдань.
- `WORKER_MODE=workflow:process,async-task:process`: Налаштовано з одним або кількома ідентифікаторами сервісів (розділеними комами), режим роботи передбачає лише обробку завдань для цих ідентифікаторів, без обробки запитів.
- `WORKER_MODE=*`: Режим роботи передбачає обробку всіх фонових завдань, незалежно від модуля, але без обробки запитів.
- `WORKER_MODE=!,workflow:process`: Режим роботи передбачає обробку запитів і одночасну обробку завдань для певного ідентифікатора.
- `WORKER_MODE=-`: Режим роботи передбачає відсутність обробки будь-яких запитів або завдань (цей режим потрібен у процесі воркера).

Наприклад, у середовищі K8S вузли з однаковою функціональністю розділення можуть використовувати однакову конфігурацію змінних середовища, що дозволяє легко масштабувати певний тип сервісу по горизонталі.

## Приклади конфігурації

### Обробка на кількох вузлах окремо

Припустімо, є три вузли: `node1`, `node2` та `node3`. Їх можна налаштувати таким чином:

- `node1`: Обробляє лише запити користувацького інтерфейсу, налаштуйте `WORKER_MODE=!`.
- `node2`: Обробляє лише завдання робочих процесів, налаштуйте `WORKER_MODE=workflow:process`.
- `node3`: Обробляє лише асинхронні завдання, налаштуйте `WORKER_MODE=async-task:process`.

### Змішана обробка на кількох вузлах

Припустімо, є чотири вузли: `node1`, `node2`, `node3` та `node4`. Їх можна налаштувати таким чином:

- `node1` та `node2`: Обробляють усі звичайні запити, налаштуйте `WORKER_MODE=!`, а балансувальник навантаження автоматично розподіляє запити між цими двома вузлами.
- `node3` та `node4`: Обробляють усі інші фонові завдання, налаштуйте `WORKER_MODE=*`.

## Довідник для розробників

При розробці бізнес-плагінів ви можете розділяти сервіси, що споживають значні ресурси, залежно від вимог сценарію. Це можна реалізувати такими способами:

1. Визначте новий ідентифікатор сервісу, наприклад, `my-plugin:process`, для конфігурації змінної середовища та надайте відповідну документацію.
2. У бізнес-логіці на стороні сервера плагіна використовуйте інтерфейс `app.serving()` для перевірки середовища та визначення, чи повинен поточний вузол надавати певний сервіс на основі змінної середовища.

```javascript
const MY_PLUGIN_SERVICE_KEY = 'my-plugin:process';
// У коді плагіна на стороні сервера
if (this.app.serving(MY_PLUGIN_SERVICE_KEY)) {
  // Обробка бізнес-логіки для цього сервісу
} else {
  // Не обробляти бізнес-логіку для цього сервісу
}
```