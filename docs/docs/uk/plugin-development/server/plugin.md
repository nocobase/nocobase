:::tip Повідомлення про переклад ШІ
Ця документація була автоматично перекладена штучним інтелектом.
:::


# Плагін

У NocoBase серверний плагін (Server Plugin) надає модульний спосіб розширення та налаштування функціональності серверної частини. Розробники можуть, успадкувавши клас `Plugin` з `@nocobase/server`, реєструвати події, API, конфігурації дозволів та іншу власну логіку на різних етапах життєвого циклу.

## Клас плагіна

Базова структура класу плагіна виглядає так:

```ts
import { Plugin } from '@nocobase/server';

export class PluginHelloServer extends Plugin {
  async afterAdd() {}

  async beforeLoad() {}

  async load() {}

  async install() {}

  async afterEnable() {}

  async afterDisable() {}

  async remove() {}

  async handleSyncMessage(message: Record<string, any>) {}

  static async staticImport() {}
}

export default PluginHelloServer;
```

## Життєвий цикл

Методи життєвого циклу плагіна виконуються в такому порядку. Кожен метод має свій специфічний час виконання та призначення:

| Метод життєвого циклу | Час виконання | Опис |
|---|---|---|
| **staticImport()** | До завантаження плагіна | Статичний метод класу, що виконується на етапі ініціалізації, незалежному від стану застосунку чи плагіна. Використовується для ініціалізації, яка не залежить від екземплярів плагіна. |
| **afterAdd()** | Виконується відразу після додавання плагіна до менеджера плагінів | Екземпляр плагіна вже створено, але не всі плагіни завершили ініціалізацію. Можна виконати деякі базові ініціалізаційні роботи. |
| **beforeLoad()** | Виконується перед методом `load()` усіх плагінів | На цьому етапі Ви можете отримати доступ до всіх **увімкнених екземплярів плагінів**. Підходить для реєстрації моделей бази даних, прослуховування подій бази даних, реєстрації проміжного програмного забезпечення та інших підготовчих робіт. |
| **load()** | Виконується під час завантаження плагіна | Усі методи `beforeLoad()` плагінів завершуються перед початком виконання `load()`. Підходить для реєстрації ресурсів, API-інтерфейсів, сервісів та іншої основної бізнес-логіки. |
| **install()** | Виконується при першій активації плагіна | Виконується лише один раз, коли плагін увімкнено вперше. Зазвичай використовується для ініціалізації структури таблиць бази даних, вставки початкових даних та іншої логіки встановлення. |
| **afterEnable()** | Виконується після увімкнення плагіна | Виконується кожного разу, коли плагін увімкнено. Може використовуватися для запуску запланованих завдань, реєстрації запланованих завдань, встановлення з'єднань та інших дій після увімкнення. |
| **afterDisable()** | Виконується після вимкнення плагіна | Виконується при вимкненні плагіна. Може використовуватися для очищення ресурсів, зупинки завдань, закриття з'єднань та інших робіт з очищення. |
| **remove()** | Виконується при видаленні плагіна | Виконується при повному видаленні плагіна. Використовується для написання логіки видалення, наприклад, видалення таблиць бази даних, очищення файлів тощо. |
| **handleSyncMessage(message)** | Синхронізація повідомлень у багатонодовому розгортанні | Коли застосунок працює в багатонодовому режимі, використовується для обробки повідомлень, синхронізованих з інших вузлів. |

### Опис порядку виконання

Типовий потік виконання методів життєвого циклу:

1. **Етап статичної ініціалізації**: `staticImport()`
2. **Етап запуску застосунку**: `afterAdd()` → `beforeLoad()` → `load()`
3. **Етап першого увімкнення плагіна**: `afterAdd()` → `beforeLoad()` → `load()` → `install()`
4. **Етап повторного увімкнення плагіна**: `afterAdd()` → `beforeLoad()` → `load()`
5. **Етап вимкнення плагіна**: `afterDisable()` виконується при вимкненні плагіна
6. **Етап видалення плагіна**: `remove()` виконується при видаленні плагіна

## `app` та пов'язані члени

Під час розробки плагінів Ви можете отримати доступ до різних API, що надаються екземпляром застосунку, через `this.app`. Це є основним інтерфейсом для розширення функціональності плагіна. Об'єкт `app` містить різні функціональні модулі системи. Розробники можуть використовувати ці модулі в методах життєвого циклу плагіна для реалізації бізнес-вимог.

### Список членів `app`

| Назва члена | Тип/Модуль | Основне призначення |
|---|---|---|
| **logger** | `Logger` | Записує системні журнали, підтримує виведення журналів різних рівнів (info, warn, error, debug), що зручно для налагодження та моніторингу. Див. [Журнали](./logger.md) |
| **db** | `Database` | Надає операції рівня ORM, реєстрацію моделей, прослуховування подій, контроль транзакцій та інші функції, пов'язані з базою даних. Див. [База даних](./database.md). |
| **resourceManager** | `ResourceManager` | Використовується для реєстрації та управління ресурсами REST API та обробниками операцій. Див. [Керування ресурсами](./resource-manager.md). |
| **acl** | `ACL` | Рівень контролю доступу, що використовується для визначення дозволів, ролей та політик доступу до ресурсів, реалізуючи детальний контроль дозволів. Див. [Контроль доступу (ACL)](./acl.md). |
| **cacheManager** | `CacheManager` | Керує кешем системного рівня, підтримує Redis, кеш у пам'яті та інші бекенди кешування для підвищення продуктивності застосунку. Див. [Кеш](./cache.md) |
| **cronJobManager** | `CronJobManager` | Використовується для реєстрації, запуску та управління запланованими завданнями, підтримує конфігурацію виразів Cron. Див. [Заплановані завдання](./cron-job-manager.md) |
| **i18n** | `I18n` | Підтримка інтернаціоналізації, надає функції багатомовного перекладу та локалізації, що зручно для плагінів для підтримки кількох мов. Див. [Інтернаціоналізація](./i18n.md) |
| **cli** | `CLI` | Керує інтерфейсом командного рядка, реєструє та виконує власні команди, розширює функціональність NocoBase CLI. Див. [Командний рядок](./command.md) |
| **dataSourceManager** | `DataSourceManager` | Керує кількома екземплярами джерел даних та їх з'єднаннями, підтримує сценарії з кількома джерелами даних. Див. [Керування джерелами даних](./collections.md) |
| **pm** | `PluginManager` | Менеджер плагінів, що використовується для динамічного завантаження, увімкнення, вимкнення, видалення плагінів, а також для керування залежностями між плагінами. |

> Порада: Детальну інформацію про використання кожного модуля дивіться у відповідних розділах документації.