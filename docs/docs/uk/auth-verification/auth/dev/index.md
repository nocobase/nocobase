:::tip Повідомлення про переклад ШІ
Ця документація була автоматично перекладена штучним інтелектом.
:::


# Розширення типів автентифікації

## Огляд

NocoBase дозволяє розширювати типи автентифікації користувачів за потреби. Зазвичай існує два типи автентифікації користувачів: перший – це визначення особи користувача безпосередньо в застосунку NocoBase, наприклад, вхід за паролем або SMS; другий – це коли сторонні сервіси визначають особу користувача та повідомляють застосунок NocoBase про результат через зворотні виклики, наприклад, методи автентифікації OIDC, SAML тощо. Процес автентифікації для цих двох типів у NocoBase виглядає наступним чином:

### Без сторонніх зворотних викликів

1. Клієнт використовує NocoBase SDK для виклику інтерфейсу входу `api.auth.signIn()`, надсилаючи запит до інтерфейсу `auth:signIn`, при цьому передаючи ідентифікатор поточного автентифікатора через заголовок запиту `X-Authenticator` на бек-енд.
2. Інтерфейс `auth:signIn`, використовуючи ідентифікатор автентифікатора із заголовка запиту, перенаправляє запит до відповідного типу автентифікації. Метод `validate` у зареєстрованому класі автентифікації цього типу виконує відповідну логічну обробку.
3. Клієнт отримує інформацію про користувача та токен автентифікації з відповіді інтерфейсу `auth:signIn`, зберігає токен у Local Storage та завершує вхід. Цей крок автоматично обробляється всередині SDK.

<img src="https://static-docs.nocobase.com/202404211852848.png"/>

### Зі сторонніми зворотними викликами

1. Клієнт отримує URL-адресу стороннього входу через власноруч зареєстрований інтерфейс (наприклад, `auth:getAuthUrl`), передаючи згідно з протоколом таку інформацію, як назва застосунку та ідентифікатор автентифікатора.
2. Перенаправлення на сторонню URL-адресу для завершення входу. Сторонній сервіс викликає інтерфейс зворотного виклику застосунку NocoBase (який потрібно зареєструвати самостійно, наприклад, `auth:redirect`), повертає результат автентифікації, а також інформацію, таку як назва застосунку та ідентифікатор автентифікатора.
3. Метод інтерфейсу зворотного виклику розбирає параметри для отримання ідентифікатора автентифікатора, через `AuthManager` отримує відповідний клас автентифікації та активно викликає метод `auth.signIn()`. Метод `auth.signIn()` викликає метод `validate()` для обробки логіки авторизації.
4. Метод зворотного виклику отримує токен автентифікації, потім перенаправляє (302) назад на фронтенд-сторінку, передаючи `token` та ідентифікатор автентифікатора в параметрах URL, наприклад, `?authenticator=xxx&token=yyy`.

<img src="https://static-docs.nocobase.com/202404211852377.png"/>

Далі ми розглянемо, як зареєструвати серверні інтерфейси та клієнтські інтерфейси користувача.

## Серверна частина

### Інтерфейс автентифікації

Ядро NocoBase надає можливості для реєстрації та управління розширеними типами автентифікації. Обробка основної логіки для розширення плагіна входу вимагає успадкування від абстрактного класу `Auth` ядра та реалізації відповідних стандартних інтерфейсів.  
Повну довідку API дивіться у [Auth](/api/auth/auth).

```typescript
import { Auth } from '@nocobase/auth';

class CustomAuth extends Auth {
  set user(user) {}
  get user() {}

  async check() {}
  async signIn() {}
}
```

Ядро також реєструє базові операції з ресурсами, пов'язані з автентифікацією користувачів.

| API            | Опис             |
| -------------- | ---------------- |
| `auth:check`   | Перевірити, чи користувач увійшов |
| `auth:signIn`  | Увійти             |
| `auth:signUp`  | Зареєструватися             |
| `auth:signOut` | Вийти         |

У більшості випадків розширений тип автентифікації користувачів також може використовувати наявну логіку авторизації JWT для генерації облікових даних для доступу користувачів до API. Клас `BaseAuth` у ядрі містить базову реалізацію абстрактного класу `Auth`; дивіться [BaseAuth](../../../api/auth/base-auth.md). Плагіни можуть безпосередньо успадковувати клас `BaseAuth`, щоб повторно використовувати частину логічного коду та знизити витрати на розробку.

```javascript
import { BaseAuth } from '@nocobase/auth';

class CustomAuth extends BaseAuth {
  constructor(config: AuthConfig) {
    // Встановити колекцію користувачів
    const userCollection = config.ctx.db.getCollection('users');
    super({ ...config, userCollection });
  }

  // Реалізувати логіку автентифікації користувача
  async validate() {}
}
```

### Дані користувача

При реалізації логіки автентифікації користувача зазвичай включається обробка даних користувача. У застосунку NocoBase відповідні колекції за замовчуванням визначені як:

| Колекція                | Опис                                                                                                          | Плагін                                                            |
| --------------------- | -------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| `users`               | Зберігає інформацію про користувача, таку як електронна пошта, нікнейм та пароль                                                        | [Плагін користувачів (`@nocobase/plugin-users`)](/users-permissions/user) |
| `authenticators`      | Зберігає інформацію про автентифікатори (сутності типу автентифікації), що відповідає типу автентифікації та конфігурації | Плагін автентифікації користувачів (`@nocobase/plugin-auth`)              |
| `usersAuthenticators` | Пов'язує користувачів та автентифікатори, зберігає інформацію про користувача під відповідним автентифікатором                    | Плагін автентифікації користувачів (`@nocobase/plugin-auth`)              |

Зазвичай розширені методи входу використовують колекції `users` та `usersAuthenticators` для зберігання відповідних даних користувача. Лише в особливих випадках вам потрібно буде самостійно додавати нову колекцію.

Основними полями колекції `usersAuthenticators` є:

| Поле            | Опис                                                                                 |
| --------------- | ------------------------------------------------------------------------------------------- |
| `uuid`          | Унікальний ідентифікатор користувача для цього типу автентифікації, наприклад, номер телефону або openid WeChat |
| `meta`          | Поле JSON, інша інформація, яку потрібно зберегти                                                   |
| `userId`        | ID користувача                                                                                     |
| `authenticator` | Назва автентифікатора (унікальний ідентифікатор)                                                      |

Для операцій запиту та створення користувачів модель даних `AuthModel` автентифікаторів також інкапсулює кілька методів, які можна використовувати в класі `CustomAuth` через `this.authenticator[ім'яМетоду]`. Повну довідку API дивіться у [AuthModel](./api#authmodel).

```ts
import { AuthModel } from '@nocobase/plugin-auth';

class CustomAuth extends BaseAuth {
  async validate() {
    // ...
    const authenticator = this.authenticator as AuthModel;
    this.authenticator.findUser(); // Запит користувача
    this.authenticator.newUser(); // Створити нового користувача
    this.authenticator.findOrCreateUser(); // Запитати або створити нового користувача
    // ...
  }
}
```

### Реєстрація типу автентифікації

Розширений метод автентифікації потрібно зареєструвати в модулі управління автентифікацією.

```javascript
class CustomAuthPlugin extends Plugin {
  async load() {
    this.app.authManager.registerTypes('custom-auth-type', {
      auth: CustomAuth,
    });
  }
}
```

## Клієнтська частина

Клієнтський інтерфейс користувача реєструється через інтерфейс `registerType`, наданий клієнтом плагіна автентифікації користувачів:

```ts
import AuthPlugin from '@nocobase/plugin-auth/client';

class CustomAuthPlugin extends Plugin {
  async load() {
    const auth = this.app.pm.get(AuthPlugin);
    auth.registerType('custom-auth-type', {
      components: {
        SignInForm, // Форма входу
        SignInButton, // Кнопка входу (стороннього), може бути альтернативою формі входу
        SignUpForm, // Форма реєстрації
        AdminSettingsForm, // Форма налаштувань адміністратора
      },
    });
  }
}
```

### Форма входу

![](https://static-docs.nocobase.com/33afe18f229c3db45c7a1921c2c050b7.png)

Якщо кілька автентифікаторів, що відповідають типу автентифікації, зареєстрували форми входу, вони відображатимуться у вигляді вкладок. Заголовок вкладки буде назвою автентифікатора, налаштованою в бек-енді.

![](https://static-docs.nocobase.com/ada6d7add744be0c812359c23bf4c7fc.png)

### Кнопка входу

![](https://static-docs.nocobase.com/e706f7785782adc77b0f4ee4faadfab8.png)

Зазвичай це кнопки стороннього входу, але насправді це може бути будь-який компонент.

### Форма реєстрації

![](https://static-docs.nocobase.com/f95c53431bf21ec312fcfd51923f0b42.png)

Якщо вам потрібно перейти зі сторінки входу на сторінку реєстрації, це потрібно обробити самостійно в компоненті входу.

### Форма налаштувань адміністратора

![](https://static-docs.nocobase.com/f4b544b5b0f5afee5621ad4abf66b24f.png)

Вгорі знаходиться загальна конфігурація автентифікатора, а внизу – частина форми користувацьких налаштувань, яку можна зареєструвати.

### Запити до API

Щоб ініціювати на клієнтській стороні запити до інтерфейсів, пов'язаних з автентифікацією користувачів, можна використовувати SDK, наданий NocoBase.

```ts
import { useAPIClient } from '@nocobase/client';

// використовувати в компоненті
const api = useAPIClient();
api.auth.signIn(data, authenticator);
```

Детальну довідку API дивіться у [@nocobase/sdk - Auth](/api/sdk/auth).