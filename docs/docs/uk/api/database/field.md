:::tip Повідомлення про переклад ШІ
Ця документація була автоматично перекладена штучним інтелектом.
:::


# Поле

## Огляд

Клас для керування полями колекції (абстрактний клас). Він також є базовим класом для всіх типів полів. Будь-який інший тип поля реалізується шляхом успадкування від цього класу.

Щоб дізнатися, як налаштувати поля, зверніться до [Розширення типів полів]

## Конструктор

Зазвичай розробники не викликають його безпосередньо, а використовують метод `db.collection({ fields: [] })` як проксі-точку входу.

При розширенні поля це реалізується переважно шляхом успадкування від абстрактного класу `Field` та подальшої реєстрації його в екземплярі Database.

**Підпис**

- `constructor(options: FieldOptions, context: FieldContext)`

**Параметри**

| Параметр               | Тип           | За замовчуванням | Опис                                     |
| -------------------- | -------------- | ------ | ---------------------------------------- |
| `options`            | `FieldOptions` | -      | Об'єкт конфігурації поля                 |
| `options.name`       | `string`       | -      | Назва поля                               |
| `options.type`       | `string`       | -      | Тип поля, що відповідає назві типу поля, зареєстрованого в db |
| `context`            | `FieldContext` | -      | Об'єкт контексту поля                    |
| `context.database`   | `Database`     | -      | Екземпляр бази даних                     |
| `context.collection` | `Collection`   | -      | Екземпляр колекції                       |

## Члени екземпляра

### `name`

Назва поля.

### `type`

Тип поля.

### `dataType`

Тип зберігання поля в базі даних.

### `options`

Параметри конфігурації ініціалізації поля.

### `context`

Об'єкт контексту поля.

## Методи конфігурації

### `on()`

Скорочений метод визначення на основі подій колекції. Еквівалентно `db.on(this.collection.name + '.' + eventName, listener)`.

Зазвичай немає потреби перевизначати цей метод при успадкуванні.

**Підпис**

- `on(eventName: string, listener: (...args: any[]) => void)`

**Параметри**

| Параметр      | Тип                       | За замовчуванням | Опис       |
| ----------- | -------------------------- | ------ | ---------- |
| `eventName` | `string`                   | -      | Назва події   |
| `listener`  | `(...args: any[]) => void` | -      | Слухач події |

### `off()`

Скорочений метод видалення на основі подій колекції. Еквівалентно `db.off(this.collection.name + '.' + eventName, listener)`.

Зазвичай немає потреби перевизначати цей метод при успадкуванні.

**Підпис**

- `off(eventName: string, listener: (...args: any[]) => void)`

**Параметри**

| Параметр      | Тип                       | За замовчуванням | Опис       |
| ----------- | -------------------------- | ------ | ---------- |
| `eventName` | `string`                   | -      | Назва події   |
| `listener`  | `(...args: any[]) => void` | -      | Слухач події |

### `bind()`

Вміст, що виконується при додаванні поля до колекції. Зазвичай використовується для додавання слухачів подій колекції та іншої обробки.

При успадкуванні спочатку потрібно викликати відповідний метод `super.bind()`.

**Підпис**

- `bind()`

### `unbind()`

Вміст, що виконується при видаленні поля з колекції. Зазвичай використовується для видалення слухачів подій колекції та іншої обробки.

При успадкуванні спочатку потрібно викликати відповідний метод `super.unbind()`.

**Підпис**

- `unbind()`

### `get()`

Отримує значення параметра конфігурації поля.

**Підпис**

- `get(key: string): any`

**Параметри**

| Параметр | Тип     | За замовчуванням | Опис       |
| ------ | -------- | ------ | ---------- |
| `key`  | `string` | -      | Назва параметра конфігурації |

**Приклад**

```ts
const field = db.collection('users').getField('name');

// Отримує значення параметра конфігурації назви поля, повертає 'name'
console.log(field.get('name'));
```

### `merge()`

Об'єднує значення параметрів конфігурації поля.

**Підпис**

- `merge(options: { [key: string]: any }): void`

**Параметри**

| Параметр    | Тип                     | За замовчуванням | Опис               |
| --------- | ------------------------ | ------ | ------------------ |
| `options` | `{ [key: string]: any }` | -      | Об'єкт параметрів конфігурації для об'єднання |

**Приклад**

```ts
const field = db.collection('users').getField('name');

field.merge({
  // Додаємо конфігурацію індексу
  index: true,
});
```

### `remove()`

Видаляє поле з колекції (лише з пам'яті).

**Приклад**

```ts
const books = db.getCollections('books');

books.getField('isbn').remove();

// дійсно видалити з бази даних
await books.sync();
```

## Методи бази даних

### `removeFromDb()`

Видаляє поле з бази даних.

**Підпис**

- `removeFromDb(options?: Transactionable): Promise<void>`

**Параметри**

| Параметр                 | Тип          | За замовчуванням | Опис     |
| ---------------------- | ------------- | ------ | -------- |
| `options.transaction?` | `Transaction` | -      | Екземпляр транзакції |

### `existsInDb()`

Визначає, чи існує поле в базі даних.

**Підпис**

- `existsInDb(options?: Transactionable): Promise<boolean>`

**Параметри**

| Параметр                 | Тип          | За замовчуванням | Опис     |
| ---------------------- | ------------- | ------ | -------- |
| `options.transaction?` | `Transaction` | -      | Екземпляр транзакції |

## Список вбудованих типів полів

NocoBase має кілька вбудованих, часто використовуваних типів полів. Ви можете безпосередньо використовувати відповідну назву типу для визначення полів колекції. Різні типи полів мають різні конфігурації параметрів, детальніше дивіться у списку нижче.

Усі параметри конфігурації для типів полів, за винятком тих, що описані нижче, будуть передані до Sequelize. Отже, тут можна використовувати всі параметри конфігурації полів, які підтримує Sequelize (наприклад, `allowNull`, `defaultValue` тощо).

Крім того, серверні типи полів переважно вирішують проблеми зберігання даних у базі даних та деяких алгоритмів, і вони, по суті, не пов'язані з типами відображення полів та компонентами, що використовуються на фронтенді. Щодо фронтенд-типів полів, будь ласка, зверніться до відповідних інструкцій у посібнику.

### `'boolean'`

Булевий тип значення.

**Приклад**

```js
db.collection({
  name: 'books',
  fields: [
    {
      type: 'boolean',
      name: 'published',
    },
  ],
});
```

### `'integer'`

Цілочисельний тип (32-бітний).

**Приклад**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'integer',
      name: 'pages',
    },
  ],
});
```

### `'bigInt'`

Великий цілочисельний тип (64-бітний).

**Приклад**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'bigInt',
      name: 'words',
    },
  ],
});
```

### `'double'`

Тип з плаваючою комою подвійної точності (64-бітний).

**Приклад**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'double',
      name: 'price',
    },
  ],
});
```

### `'real'`

Тип дійсного числа (лише для PG).

### `'decimal'`

Десятковий числовий тип.

### `'string'`

Рядковий тип. Еквівалентний типу `VARCHAR` у більшості баз даних.

**Приклад**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'string',
      name: 'title',
    },
  ],
});
```

### `'text'`

Текстовий тип. Еквівалентний типу `TEXT` у більшості баз даних.

**Приклад**

```ts
db.collection({
  name: 'books',
  fields: [
    {
      type: 'text',
      name: 'content',
    },
  ],
});
```

### `'password'`

Тип пароля (розширення NocoBase). Шифрує паролі на основі методу `scrypt` з вбудованого пакета `crypto` Node.js.

**Приклад**

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'password',
      name: 'password',
      length: 64, // Довжина, за замовчуванням 64
      randomBytesSize: 8, // Довжина випадкових байтів, за замовчуванням 8
    },
  ],
});
```

**Параметри**

| Параметр            | Тип     | За замовчуванням | Опис         |
| ----------------- | -------- | ------ | ------------ |
| `length`          | `number` | 64     | Довжина символів     |
| `randomBytesSize` | `number` | 8      | Розмір випадкових байтів |

### `'date'`

Тип дати.

### `'time'`

Тип часу.

### `'array'`

Тип масиву (лише для PG).

### `'json'`

Тип JSON.

### `'jsonb'`

Тип JSONB (лише для PG, інші будуть сумісні як тип `'json'` ).

### `'uuid'`

Тип UUID.

### `'uid'`

Тип UID (розширення NocoBase). Тип короткого випадкового рядкового ідентифікатора.

### `'formula'`

Тип формули (розширення NocoBase). Дозволяє налаштовувати обчислення математичних формул на основі [mathjs](https://www.npmjs.com/package/mathjs). Формула може посилатися на значення інших стовпців у тому ж записі для обчислення.

**Приклад**

```ts
db.collection({
  name: 'orders',
  fields: [
    {
      type: 'double',
      name: 'price',
    },
    {
      type: 'integer',
      name: 'quantity',
    },
    {
      type: 'formula',
      name: 'total',
      expression: 'price * quantity',
    },
  ],
});
```

### `'radio'`

Тип радіокнопки (розширення NocoBase). Щонайбільше один рядок даних у всій колекції може мати значення цього поля як `true`; усі інші будуть `false` або `null`.

**Приклад**

У всій системі є лише один користувач, позначений як root. Після того, як значення root будь-якого іншого користувача буде змінено на `true`, усі інші записи з root як `true` будуть змінені на `false`:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'radio',
      name: 'root',
    },
  ],
});
```

### `'sort'`

Тип сортування (розширення NocoBase). Сортує на основі цілих чисел, автоматично генерує новий порядковий номер для нових записів і переупорядковує порядкові номери при переміщенні даних.

Якщо колекція визначає опцію `sortable`, відповідне поле також буде автоматично згенеровано.

**Приклад**

Публікації можна сортувати на основі користувача, якому вони належать:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsTo',
      name: 'user',
    },
    {
      type: 'sort',
      name: 'priority',
      scopeKey: 'userId', // Сортувати дані, згруповані за однаковим значенням userId
    },
  ],
});
```

### `'virtual'`

Віртуальний тип. Фактично не зберігає дані, використовується лише для визначення спеціальних геттерів/сеттерів.

### `'belongsTo'`

Тип зв'язку «багато до одного». Зовнішній ключ зберігається у власній таблиці, на відміну від hasOne/hasMany.

**Приклад**

Будь-яка публікація належить автору:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsTo',
      name: 'author',
      target: 'users', // Якщо не налаштовано, за замовчуванням використовується назва колекції у множині
      foreignKey: 'authorId', // Якщо не налаштовано, за замовчуванням використовується формат `<name> + Id`
      sourceKey: 'id', // Якщо не налаштовано, за замовчуванням використовується id цільової колекції
    },
  ],
});
```

### `'hasOne'`

Тип зв'язку «один до одного». Зовнішній ключ зберігається в асоційованій колекції, на відміну від belongsTo.

**Приклад**

Кожен користувач має профіль:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'hasOne',
      name: 'profile',
      target: 'profiles', // Можна опустити
    },
  ],
});
```

### `'hasMany'`

Тип зв'язку «один до багатьох». Зовнішній ключ зберігається в асоційованій колекції, на відміну від belongsTo.

**Приклад**

Будь-який користувач може мати кілька публікацій:

```ts
db.collection({
  name: 'users',
  fields: [
    {
      type: 'hasMany',
      name: 'posts',
      foreignKey: 'authorId',
      sourceKey: 'id',
    },
  ],
});
```

### `'belongsToMany'`

Тип зв'язку «багато до багатьох». Використовує проміжну колекцію для зберігання зовнішніх ключів обох сторін. Якщо існуюча колекція не вказана як проміжна, вона буде створена автоматично.

**Приклад**

Будь-яка публікація може мати кілька тегів, і будь-який тег може бути доданий до кількох публікацій:

```ts
db.collection({
  name: 'posts',
  fields: [
    {
      type: 'belongsToMany',
      name: 'tags',
      target: 'tags', // Можна опустити, якщо назва збігається
      through: 'postsTags', // Проміжна колекція буде автоматично згенерована, якщо не налаштовано
      foreignKey: 'postId', // Зовнішній ключ вихідної колекції в проміжній колекції
      sourceKey: 'id', // Первинний ключ вихідної колекції
      otherKey: 'tagId', // Зовнішній ключ цільової колекції в проміжній колекції
    },
  ],
});

db.collection({
  name: 'tags',
  fields: [
    {
      type: 'belongsToMany',
      name: 'posts',
      through: 'postsTags', // Одна й та сама група зв'язків вказує на одну й ту саму проміжну колекцію
    },
  ],
});
```